  import React from 'react';
import { NSAjax } from 'nsajax';

import { NSAjaxReact } from '../lib/nsAjax/nsAjaxReact';
import { NSMessageBoxReact, INSMessageBoxReactSettings } from '../lib/nsMessageBox/nsMessageBoxReact';

import { Authenticate } from "./routes/authenticate";
import { RptHeader } from "./rptHeader";
import { LoadingSpinner } from '../lib/loadingSpinner/loadingSpinner';

import {GlobalContext} from './GlobalContext';
import {ErrorBoundary} from './errorBoundary';
import { PopUpService } from '../modules/helper/popUpService';
import { NSReactEvent } from '../modules/helper/nsReactEvent';
import { Constants } from '../modules/helper/constants';

import { Spoof } from "../modules/spoof/spoof";
import { AccessMessage } from "../modules/access/accessMessage";

class App extends React.Component<any,any>
{
    private compLoader: LoadingSpinner = null;
    private spoof: Spoof = null;

    private modal: NSMessageBoxReact;
    private appContainer: HTMLDivElement;
    private appHeader:RptHeader ;
    private resizeHandlerRef: any;


    constructor(public props: any, public state: any) 
    {
        super(props,state);
        let emplID: string = this.getUrlParameter("emplID");
        let eacQueueId: string = this.getUrlParameter("eacQueueId");
        let ajax: NSAjaxReact = new NSAjaxReact();
        this.state = 
        {
                ajax: ajax,
 				//url: "api/",
                url: "http://localhost:9080/complianceportal/RPT/api/",
                userObj: null,
                emLink: null,
                emplID: emplID,
                eacQueueId: eacQueueId,
                region: "",
                arrRegion: [],
                arrRegionLabel: [],
                nefGroup: "",
                arrNefGroup: [],
                setProp: this.setContextState.bind(this),
                getURL: this.getURL.bind(this),
                globalCatchBlock: this.globalCatchBlock.bind(this),
                globalIntercept: this.globalIntercept.bind(this),
                modal: null,
                popUpService: null,
                loader: null,
                spoof:null,
                showSpoof:false,
                showAuthenticate:false,
                employeeAccess:false
        };
        
      this.getUserInfo();
        
    }
    
    render()
    {
        //const item: any = {ajax: ajax,url: this.url,userObj: null};
        //const useAuthState = React.useReducer(globalReducer, item);
        const containerStyle: any = {"height": window.innerHeight - 20};
        const pageContent: any = {"margin": "5px","height": "100%"};
        const { showAuthenticate, showSpoof , employeeAccess } = this.state;
        const modalSetting: INSMessageBoxReactSettings = {enableModalCloseOnEscape: true,enableCloseIconVisibility: true};
       
        const loginAsSomeone: any = this.loginAsSelf.bind(this);
        const loginAsSelected: any = this.loginAsSelected.bind(this);
        return (
                <GlobalContext.Provider value={this.state}>
                    <ErrorBoundary>
                      <div id="divAppContainer" ref={(ref) => this.appContainer = ref} className="App" style={containerStyle}>
                          <div id="divContent" className="nmPageContent" style={pageContent}>
                          <RptHeader ref={(ref) => this.appHeader = ref}></RptHeader>
                      {showAuthenticate && (
                            <Authenticate>
                            </Authenticate>
                      )}
                      {showSpoof && (
                           <Spoof id="divSpoof" ref={(ref) => this.spoof = ref} loginAsSelf={loginAsSomeone} loginAsSelected={loginAsSelected} ></Spoof>
                           )}
                      {!showSpoof && employeeAccess && (
                              <AccessMessage></AccessMessage>
                              )}
                          </div>
                          <LoadingSpinner id="divLoader" ref={(ref) => this.compLoader = ref}></LoadingSpinner>
                          <NSMessageBoxReact setting={modalSetting} ref={(ref) => this.modal = ref} />
                      </div>
                    </ErrorBoundary>
                </GlobalContext.Provider>
        );
    }

    
    hideComponent(name) {
        switch (name) {
          case "showAuthenticate":
            this.setState({ showAuthenticate: true });
            break;
          case "showAuthenticate":
            this.setState({ showSpoof: true });
            break;
          default:
            break;;
        }
      }
    
    
    componentDidMount() 
    {
        let self = this;
        window.addEventListener(NSAjax.REQUEST_STARTED,function(){
            //self.compLoader.show();
            self.state.loader.show();
        });
        window.addEventListener(NSAjax.ALL_REQUEST_COMPLETED,function(){
           self.compLoader.hide();
           
        });
        this.setState({modal: this.modal,popUpService: new PopUpService(this.modal),loader: this.compLoader});
      
        if(this.resizeHandlerRef)
        {
            window.removeEventListener('resize', this.resizeHandlerRef);
            this.resizeHandlerRef = null;
        }
        this.resizeHandlerRef = this.debounce(this.resizeHandler.bind(this), 800);
        window.addEventListener('resize', this.resizeHandlerRef);
    }
    
    componentWillUnmount() 
    {
        if(this.resizeHandlerRef)
        {
            window.removeEventListener('resize', this.resizeHandlerRef);
            this.resizeHandlerRef = null;
        }
    }
    
    private resizeHandler(event: any)
    {
        this.appContainer.style.height = window.innerHeight + "px";
        NSReactEvent.getInstance().dispatch(Constants.SCREEN_RESIZED,{width: window.innerWidth,hieght:window.innerHeight});
    }
    
    private debounce(fn, ms) 
    {
        let timer
        return _ => {
          clearTimeout(timer)
          timer = setTimeout(_ => {
            timer = null
            fn.apply(this)
          }, ms)
        };
     };
    
    private getURL(methodName:string): string
    {
      return (this.state.url + methodName);
    }
    
    private globalIntercept(response: any,callback: any)
    {
       if(response && response["STATUS"] && response["STATUS"] === "FAILURE")
       {
           this.globalCatchBlock(response["MESSAGE"]);
       }
       else if(callback)
       {
           callback(response);
       }
    }
    
    private globalCatchBlock(error: any)
    {
        if(error)
        {
            this.state.popUpService.showFailureAlertPopup(error);
        }
    }
    
    private setContextState(item: any): void
    {
        this.setState(item);
    }
    
    private getUrlParameter(name: any) 
    {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(window.location.hash);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    };
  

    private getUserInfo(): void
    {
        const self : any = this;
        self.state.ajax.post(self.state.getURL("getLoginInfo"),null)
        .then(function(response: any)
         {
            self.state.globalIntercept(response,function(response){
                if(response)
                { 
                    console.log(response) ; 
                    if(response.isSpoofingAllowed)
                    {
                                              
                        let item: any = {userObj: response,responseReceived:true,showSpoof: true, showAuthenticate: false};
                        self.state.setProp(item);
                        self.appHeader.setHeader(response) ;
                        console.log(response) ; 
                   //     self.state.spoof.style.display ="inline";
                        //self.context.history.push("/spoof") ;
                    }
                    else
                    {
                        let employeeAccess = false ;
                        let showAuthenticate = true ; 
                         
                        if(response.userRole=='Employee')
                            {
                            employeeAccess = true ;
                            showAuthenticate = false ; 
                            }
                        let item: any = {userObj: response,responseReceived:true, employeeAccess:employeeAccess,   showAuthenticate: showAuthenticate , showSpoof: false};
                        self.state.setProp(item);
                        self.appHeader.setHeader(response) ;
                       // self.context.history.push("/cwException?emplID=108366") ;
                    }
                }
                else
                {
                    self.state.popUpService.showFailureAlertPopup("Employee Details could not be fetched.");
                }
            });
         })
        .catch(err => this.state.globalCatchBlock(err));
        
        
        
    }

    
     private loginAsSelf() :void
      {
     
         
         let employeeAccess = false ;
         let showAuthenticate = true ; 
          
         if(this.state.userObj.userRole=='Employee')
             {
             employeeAccess = true ;
             showAuthenticate = false ; 
             }
        
         let item: any = {responseReceived:true, employeeAccess:employeeAccess,   showAuthenticate: showAuthenticate , showSpoof: false};
         this.state.setProp(item);
         
         
       
      }

     private loginAsSelected(item:any) :void
     {
         const self : any = this;
    
     self.state.ajax.post(self.state.getURL("getSpoofUserInfo"),{empID:item.employeeID})
     .then(function(response: any)
      {
         self.state.globalIntercept(response,function(response){
             if(response)
             { 
                
                 let employeeAccess = false ;
                 let showAuthenticate = true ; 
                  
                 if(response.userRole=='Employee')
                     {
                     employeeAccess = true ;
                     showAuthenticate = false ; 
                     }
                 let item: any = {userObj: response,responseReceived:true, employeeAccess:employeeAccess,   showAuthenticate: showAuthenticate , showSpoof: false};
                 //self.state.history.push("/ManageReports");
                 console.log(self.props)
                 self.state.setProp(item);
                 self.appHeader.setHeader(response) ;
                
             }
             else
             {
                 self.state.popUpService.showFailureAlertPopup("Employee Details could not be fetched.");
             }
         });
      })
     .catch(err => this.state.globalCatchBlock(err));
     
     }
     
      
    
    
}






export default App;
