var NSScroller = (function()
{
	function NSScroller(setting)
	{
		var self = this;
		var util = null;
		var config = {};
		
		var parentNode = null;
		var divScrollBarCorner = null;
		
		var props = {};
		
		var operaMaxScrollBarSize = 17;
		var macScrollBarSize = 15;
		var macFFRegex = /[\s\S]*Macintosh[\s\S]*\) Gecko[\s\S]*/;
		var isMacFF = macFFRegex.test(window.navigator && window.navigator.userAgent);
		
		var selectedItem = null;
		var interval = null;
		var delayInterval = null;
		var mutationObserver = null;
		var lastScrollPos = -1;
		
		var documentMouseMoveRef = null;
		var documentMouseUpRef = null;
		var documentTouchMoveRef = null;
		var documentTouchEndRef = null;
		
		var setScrollWidth = function(width)
		{
			config.scrollWidth = width;
			var item = props.horizontal;
			item.inputSize = width;
			setScrollElementSize(item);
		};
		
		var setScrollHeight = function(height)
		{
			config.scrollHeight = height;
			var item = props.vertical;
			item.inputSize = height;
			setScrollElementSize(item);
		};
		
		var setScrollTop = function(scrollTop)
		{
			var item = props.vertical;
			setScrollPos(item,scrollTop);
		};
		
		var getScrollTop = function()
		{
			var item = props.vertical;
			return item.element[item.scroll];
		};
		
		var setScrollLeft = function(scrollLeft)
		{
			var item = props.horizontal;
			setScrollPos(item,scrollLeft);
		};
		
		var getScrollLeft = function()
		{
			var item = props.horizontal;
			return item.element[item.scroll];
		};
		
		var getVerticalScrollHeight = function()
		{
			var item = props.vertical;
			return item.element[item.scrollSize];
		};
		
		var getHorizontalScrollWidth = function()
		{
			var item = props.horizontal;
			return item.element[item.scrollSize];
		};
		
		var hasHorizontalScroller = function()
		{
			return hasScroll(props.horizontal);
		};
		
		var hasVerticalScroller = function()
		{
			return hasScroll(props.vertical);
		};
		
		var getHorizontalScroller = function()
		{
			var item = props.horizontal;
			return item.container;
		};
		
		var getVerticalScroller = function()
		{
			var item = props.vertical;
			return item.container;
		};
		
		var getHorizontalBar = function()
		{
			var item = props.horizontal;
			return item.scroller;
		};
		
		var getVertcialBar = function()
		{
			var item = props.vertical;
			return item.scroller;
		};
		
		var initialize = function()
		{
			util = new NSUtil();
			setConfig();
			setProps();
			util.addStyleClass(config.element,"nsScrollerScrollable");
			createComponent();
			util.addEvent(config.element,"mousewheel",mouseWheelHandler);
			util.addEvent(config.element,"scroll",bodyScrollHandler);
			if(config.otherScrollableElement && config.otherScrollableElement.length > 0)
			{
				for(var count = 0;count < config.otherScrollableElement.length;count++)
				{
					var element = config.otherScrollableElement[count];
					util.addEvent(element,"mousewheel",mouseWheelHandler);
				}
			}
			util.addStyleClass(config.element,"nsScrollerElement");
			updateScrollBars();
			util.addEvent(window,"resize",updateWithDelay);
			addObserver();
		};
		
		var setConfig = function()
		{
			if(!setting)
			{
				setting = {};
			}
			config = {
				parentElement : setting["parentElement"],
				element : setting["element"],
				otherScrollableElement : setting["otherScrollableElement"],//for Grid if we have left,center and right body
				horizontalScrollButtons: setting["horizontalScrollButtons"] || {enable:false,leftHTML:null,rightHTML:null},
				verticalScrollButtons: setting["verticalScrollButtons"] || {enable:false,topHTML:null,bottomHTML:null},
				elementPosition: setting["elementPosition"] || "relative" ,// if content has fixable headers then use static (values: static,relative,absolute)
				enableCustomHandler: Boolean.parse(setting["enableCustomHandler"]),
				scrollWidth: setting["scrollWidth"],
				scrollHeight: setting["scrollHeight"]
			};
			if(!config.element)
			{
				util.throwNSError("NSScroller","Element in setting is missing");
			}
			if(!config.parentElement)
			{
				config.parentElement = config.element.parentNode;
			}
			parentNode = config.element.parentNode;
			if(config.horizontalScrollButtons.enable)
			{
				if(!config.horizontalScrollButtons.leftHTML)
				{
					config.horizontalScrollButtons.leftHTML = '&#9668;';
				}
				if(!config.horizontalScrollButtons.rightHTML)
				{
					config.horizontalScrollButtons.rightHTML = '&#9658;';
				}
			}
			if(config.verticalScrollButtons.enable)
			{
				if(!config.verticalScrollButtons.topHTML)
				{
					config.verticalScrollButtons.topHTML = '&#9650;';
				}
				if(!config.verticalScrollButtons.bottomHTML)
				{
					config.verticalScrollButtons.bottomHTML = '&#9660;';
				}
			}
		};
		
		var setProps = function()
		{
			props = {
				    vertical: {
				        x: "Y",direction:"v", displayDirection:"vertical", pos: "top", 
				        size: "height",crossSize: "width", crossMinSize: "min-width", crossMaxSize: "max-width",
				        client: "clientHeight", crossClient: "clientWidth",
				        scrollEdge: "scrollLeft",offset: "offsetHeight", crossOffset: "offsetWidth", offsetPos: "offsetTop",
				        scroll: "scrollTop", scrollSize: "scrollHeight",barTopLimit:0,containerCSS:"nsScrollerVerticalContainer",
				        scrollerCSS:"nsScrollerVerticalBar",buttonProp:"verticalScrollButtons",beforeButtonProp:"topHTML",
				        afterButtonProp:"bottomHTML",beforeButtonCSS:"nsScrollerButtonUp",afterButtonCSS:"nsScrollerButtonDown",
				        elementPosition:config.elementPosition,inputSize:config.scrollHeight
				    },
				    horizontal: {
				        x: "X",direction:"h",displayDirection:"horizontal", pos: "left",
				        size: "width",crossSize: "height", crossMinSize: "min-height", crossMaxSize: "max-height",
				        client: "clientWidth", crossClient: "clientHeight",
				        scrollEdge: "scrollTop",offset: "offsetWidth", crossOffset: "offsetHeight", offsetPos: "offsetLeft",
				        scroll: "scrollLeft", scrollSize: "scrollWidth",barTopLimit:0,containerCSS:"nsScrollerHorizontal",
				        scrollerCSS:"nsScrollerHorizontalBar",buttonProp:"horizontalScrollButtons",beforeButtonProp:"leftHTML",
				        afterButtonProp:"rightHTML",beforeButtonCSS:"nsScrollerButtonLeft",afterButtonCSS:"nsScrollerButtonRight",
				        elementPosition:config.elementPosition,inputSize:config.scrollWidth
				    }
			};
		};
		
		var setScrollPos = function(item,scrollPos)
		{
			selectedItem = item;
			if(selectedItem)
			{
				util.addEvent(selectedItem.element,"scroll",scrollableElementScrollHandler);
				setScrollableItems(selectedItem,scrollPos);
			}
		};
		
		var applyStyle = function(item,on) 
		{
	        var overflow = on ? 'hidden' : null;
	        var msOverflowStyle = on ? 'none' : null;
	
	        util.css(parentNode, {
	            overflow: overflow,
	            msOverflowStyle: msOverflowStyle,
	            position: (item.elementPosition == 'static') ? '' : 'relative'
	        });
	
	        var scroll = on ? 'scroll' : null;
	        var axis = item.direction == 'v' ? 'y' : 'x';
	        var css = {};
	
	        css['overflow-' + axis] = scroll;
	        css['box-sizing'] = 'border-box';
	        css.margin = '0';
	        css.border = '0';
	
	        if(item.elementPosition == 'absolute') 
	        {
	        	css.position = 'absolute';
	        	css.top = '0';
	
	            if (item.direction == 'h') 
	            {
	            	css.left = '0';
	            } 
	            else 
	            {
	            	css.bottom = '0';
	            	css.right = item.rtl ? '0' : '';
	            	css.left = item.rtl ? '' : '0';
	            }
	        }
	        util.css(config.element,css);
	    };
	    
	    var onScrollerContainerMouseDown = function(event) 
		{
	    	event = util.getEvent(event);
	    	var target = null;
			if(util.hasStyleClass(event.target,"nsScrollerBarParent"))
			{
				target = event.target.querySelector(".nsScrollerBar");
			}
			setSelectedItem(event,target);
			if(selectedItem)
			{
				var scroller = selectedItem.scroller;
				var offsetX = event["offset" + selectedItem.x];
				var xBar = scroller[selectedItem.offsetPos];
	            var moveOffset = 0;
	            if (offsetX < xBar) 
	            {
	            	moveOffset = -1;
	            } 
	            else if (offsetX > xBar + scroller[selectedItem.offset]) 
	            {
	            	moveOffset = 1;
	            }
	            var y = scrollableElementPosition(selectedItem) + moveOffset * 0.9 * config.element[selectedItem.client];
	            scrollableElementPosition(selectedItem,y);
			}
		};
		
		var onScrollerMouseDown = function(event,scroller) 
		{
			setSelectedItem(event);
			if(selectedItem)
			{
			    event.preventDefault();
			    event.stopPropagation();
			    if(selectedItem.activeCSS)
			    {
			    	util.addStyleClass(selectedItem.scroller,selectedItem.activeCSS);
			    }
			    var eventItem = {target:selectedItem.scroller,direction:selectedItem.displayDirection,scrollPos:selectedItem.element[selectedItem.scroll]};
			    dispatchEvent(NSScroller.SCROLL_START,eventItem,eventItem);
			}
		};
		
		var setSelectedItem = function(event,target)
		{
			target = target ? target : event.target;
			selectedItem = getItemByScroller(target);
			if(selectedItem)
			{
				selectedItem.dragging = true;
				selectedItem.scrollerPos = getCursorPosition(selectedItem,event) - selectedItem.barPos;
			}
		};
		
		var getItemByScroller = function(scroller)
		{
			for(var key in props)
			{
				var item = props[key];
				if(item.scroller == scroller)
				{
					return item;
				}
			}
			
			return null;
		};
		
		var createComponent = function()
		{
			for(var key in props)
			{
				var item = props[key];
				var container = createScroller(null,item.containerCSS,item.scrollerCSS);
				var scroller = container.children[0];
				var eleBefore = null;
				var eleAfter = null;
				var scrollerParent = container;
				if(config[item.buttonProp]["enable"])
				{
					var eleBefore = createButton(item,item.beforeButtonCSS,config[item.buttonProp][item.beforeButtonProp]);
					container.appendChild(eleBefore);
					scrollerParent = util.createDiv(null,"nsScrollerBarParent-" + item.direction);
					scrollerParent.appendChild(scroller);
					container.appendChild(scrollerParent);
					var eleAfter = createButton(item,item.afterButtonCSS,config[item.buttonProp][item.afterButtonProp]);
					container.appendChild(eleAfter);
					item.buttonBefore = eleBefore;
					item.buttonAfter = eleAfter;
				}
				util.addStyleClass(scrollerParent,"nsScrollerBarParent");
				config.parentElement.appendChild(container);
				container.style[item.crossSize] = scroller[item.crossOffset] + "px";
				var setting = {element:scroller,restriction:"parent",enableXAxis:(item.direction != "v"),enableYAxis:(item.direction == "v"),
							   dragStartingCallback:onScrollerMouseDown,draggingCallback:docMouseMoveHandler,dragEndCallback:docMouseUpHandler};
				var objDrag = new nsScrollerDraggable(setting);
				//util.addEvent(scrollerParent,"mousedown",onScrollerContainerMouseDown);
				//util.addEvent(scroller,"mousedown",onScrollerMouseDown);
				var divScrollCause = util.createDiv(null);
				divScrollCause.innerHTML = "&nbsp;";
				var divScroll = util.createDiv(null);
				var css = {};
				css["position"] = "absolute";
		        css["overflow-" + item.x.toLowerCase()] = "scroll";
		        //css["left"] = "-9999px";
		        //css["top"] = "-9999px";
		        util.css(divScroll,css);
				divScroll.appendChild(divScrollCause);
				document.body.appendChild(divScroll);
				item.scrollContainer = container;
				item.container = scrollerParent;
				item.scroller = scroller;
				item.element = divScroll;
				item.scrollableElementCause = divScrollCause;
				item.objDrag = objDrag;
				setScrollElementSize(item);
			}
			divScrollBarCorner = util.createDiv(null,"nsScrollBarCorner");
			config.parentElement.appendChild(divScrollBarCorner);
		};
		
		var createScroller = function(id,cssContainer,cssScroller)
		{
			cssContainer = cssContainer ? cssContainer : "";
			cssScroller = cssScroller ? cssScroller : "";
			var scrollContainer = util.createDiv(null,"nsScrollerContainer " + cssContainer);
			var scroller = util.createDiv(null,"nsScrollerBar " + cssScroller);
			scrollContainer.appendChild(scroller);
			return scrollContainer;
		};
		
		var createButton = function(item,css,html)
		{
			var div = util.createDiv(null,"nsScrollerControl nsScrollerControl-" + item.direction);
			div.innerHTML = html;
			util.addStyleClass(div,css);
			//util.addEvent(div,"click",btnControlClickHandler);
			util.addEvent(div,"mousedown",btnMouseDownHandler);
			util.addEvent(div,"dblclick",btnMouseDownHandler);
			util.addEvent(div,"mouseup",clearScroll);
			util.addEvent(div,"mouseout",clearScroll);
			return div;
		};
		
		var btnMouseDownHandler = function(event)
		{
			btnControlClickHandler(event);
			interval = setTimeout(function(){btnMouseDownHandler(event);}, 100);
		};
		
		var clearScroll = function(event)
		{
			clearTimeout(interval);
			interval = null;
			lastScrollPos = -1;
		};
		
		var btnControlClickHandler = function(event)
		{
			event = util.getEvent(event);
			var target = event.target;
			var parent = target.parentNode;
			var scroller = parent.querySelector(".nsScrollerBar");
			setSelectedItem(event,scroller);
			if(selectedItem)
			{
				var isAdd = true;
				if(util.hasStyleClass(target,selectedItem.beforeButtonCSS))
				{
					isAdd = false;
				}
				var oldPos = scrollableElementPosition(selectedItem);
				var newPos = isAdd ? (oldPos + 30) : (oldPos - 30);
				scrollableElementPosition(selectedItem,newPos);
				//selectedItem = null;
				event.preventDefault();
				event.stopPropagation();
			}
		};
		
		var mouseWheelHandler = function(event)
		{
			event = util.getEvent(event);
			var element = config.parentElement;
			var verticalScroller = element.querySelector(".nsScrollerVerticalBar");
			setSelectedItem(event,verticalScroller);
			if(selectedItem)
			{
				util.addEvent(selectedItem.element,"scroll",scrollableElementScrollHandler);//selectedItem.objDrag.setElementPos(null,100);
				selectedItem.element[selectedItem.scroll] += event["delta" + selectedItem.x];
			}
		};
		
		var scrollableElementScrollHandler = function(event)
		{
			event = util.getEvent(event);
			if(selectedItem)
			{
				var item = selectedItem;
				var element = item.element;
				item["barPos"] = Math.round((element[item.offset]/element[item.scrollSize]) * element[item.scroll]);
				setBarPosition(item, item["barPos"]);
				util.removeEvent(item.element,"scroll",scrollableElementScrollHandler);
			}
		};
		
		var bodyScrollHandler = function(event)
		{
			event = util.getEvent(event);
			if(!selectedItem)
			{
				var element = config.parentElement;
				var verticalScroller = element.querySelector(".nsScrollerVerticalBar");
				setSelectedItem(event,verticalScroller);
			}
			//scrollBody(selectedItem,event);
		};
		
		var docMouseMoveHandler = function(event,scroller)
		{
			event = util.getEvent(event);
			if(!selectedItem)
			{
				setSelectedItem(event,scroller);
			}
	        if(selectedItem)
	        {
	        	dragHandler(selectedItem,event);
	        	scrollBody(selectedItem,event);
	        }
		};
		
		var docMouseUpHandler = function(event)
		{
			event = util.getEvent(event);
		    if(selectedItem.activeCSS)
		    {
		    	util.removeStyleClass(selectedItem.scroller,selectedItem.activeCSS);
		    }
		    updateScrollBars();
		    var item = selectedItem;
		    selectedItem = null;
		    clearScroll();
		    var eventItem = {target:item.scroller,direction:item.displayDirection,scrollPos:item.element[item.scroll]};
		    dispatchEvent(NSScroller.SCROLL_END,eventItem,eventItem);
		};
		
		var scrollBody = function(item,event)
		{
			updateScrollPositions(item,false);
		};
		
		var dragHandler = function(item,event)
		{
			 var relPos = barPositionToRelative(item,getCursorPosition(item,event) - item.scrollerPos);
			 var subPos = item.element[item.scrollSize] - item.element[item.client];
			 var scrollPos = relPos * subPos;
			 //console.log(relPos + " * " + subPos + " = " + scrollPos);
			 setScrollableItems(item,scrollPos);
		};
		
		var setScrollableItems = function(item,scrollPos)
		{
			scrollPos = Math.round(scrollPos);
			var maxValue = item.element[item.scrollSize] - item.element[item.client];
			//console.log(scrollPos);
			if(scrollPos < 0)
			{
				scrollPos = 0;
			}
			if(scrollPos > maxValue)
			{
				scrollPos = maxValue;
			}
			if(lastScrollPos != scrollPos)
			{
				//console.log(scrollPos + " == " + item.element[item.scrollSize]);
				var lastScrollPos = item.element[item.scroll];
				item.element[item.scroll] = scrollPos;
				if(!config.enableCustomHandler)
				{
					config.element[item.scroll] = scrollPos;
					if(config.otherScrollableElement && config.otherScrollableElement.length > 0)
					{
						for(var count = 0;count < config.otherScrollableElement.length;count++)
						{
							var element = config.otherScrollableElement[count];
							element[item.scroll] = scrollPos;
						}
					}
				}
				var eventItem = {target:item.scroller,direction:item.displayDirection,oldScrollPos:lastScrollPos,newScrollPos:scrollPos};
				dispatchEvent(NSScroller.SCROLLING,eventItem,eventItem);
			}
			lastScrollPos = scrollPos;
		};
		
		var getCursorPosition = function(item,event)
		{
	    	return event["client" + item.x] || ((event.touches || {})[0] || {})["page" + item.x];
		};
		
		var updateScrollBars =  function()
		{
			for(var key in props)
			{
				var item = props[key];
				applyStyle(item,true);
				setScrollElementSize(item);
				resizeHandler(item);
				updateScrollPositions(item,true);
			}
			updateScrollControls();
		};
		
		var resizeHandler = function(item)
		{
			var updatePos = function()
			{
				 var offset = item.element[item.crossOffset];
	             var client = item.element[item.crossClient];
	             var padding = 0;
	             var oldPos, newPos;
	             if (isMacFF) 
	             {
	             	padding = macScrollBarSize;
	             }
	             else if (client > 0 && offset === 0) 
	             {
	             	offset = client + operaMaxScrollBarSize;
	             }
	             if (offset) 
	             {
	            	 var delta = offset - client + padding;
	            	 if (item.elementPosition == 'static') 
	            	 {
	                     oldPos = util.css(item.element,item.crossSize);
	                     newPos = parentNode[item.crossClient] + delta + "px";
	                     if (oldPos != newPos) 
	                     {
	                         setCrossSizes(item,item.element, newPos);
	                     }
	                 } 
	            	 else
	            	 {
	            		 var styles = {};
	                     var key = item.rtl ? 'Left' : 'Right';
	                     if (item.direction == 'h') 
	                     {
	                         key = 'Bottom';
	                     }
	                     util.css(item.element, styles);
	            	 }
	            	 
	             }
	             item.resizeLastFire = getCurrentTime();
			};
			var container = item["container"];
			var scroller = item["scroller"];
			var scrollerSize =  item["scrollerSize"];
			var barPos = item["barPos"];
			var minPeriod = (item.resizeDebounce === undefined) ? 300 : item.resizeDebounce;
		   	var delay = 0;
		   	if (getCurrentTime() - item.resizeLastFire < minPeriod) 
		   	{
	            clearTimeout(item.resizePauseTimer);
	            delay = minPeriod;
	        }
		   	if (delay) 
		   	{
		   		item.resizePauseTimer = setTimeout(updatePos, delay);
	        } 
		   	else 
		   	{
		   		updatePos();
	        }
		};
		
		var addObserver = function()
		{
			var mutationProp = { attributes: false, childList: true, subtree: true};
			var callback = function(mutationsList, observer) 
			{
				for(var count = 0;count < mutationsList.length;count++)
			    {
			    	var mutation = mutationsList[count];
			        if (mutation.type == 'childList') 
			        {
			        	updateWithDelay();
			        }
			    }
			};
			var mutationObserver = new MutationObserver(callback);
			mutationObserver.observe(config.element,mutationProp);
		};
		
		var updateWithDelay = function()
		{
			stopDelayInterval();
			delayInterval = setInterval(function() {
				updateScrollBars();
				stopDelayInterval();
	        }, 300); 
		};
		
		var stopDelayInterval = function()
		{
			if(delayInterval)
			{
				clearInterval(delayInterval);
				delayInterval = null;
			}
		};
		
		var setCrossSizes = function(item,element,size) 
		{
	        var styles = {};
	        styles[item.crossSize] = size;
	        styles[item.crossMinSize] = size;
	        styles[item.crossMaxSize] = size;
	        util.css(element, styles);
	    };
		
		var getCurrentTime = function()
		{
			 return new Date().getTime();
		};
		
		var updateScrollPositions = function(item,isReset,isSetBarPos)
		{
			checkScroll(item);
			var container = item["container"];
			var scroller = item["scroller"];
			var scrollerSize =  item["scrollerSize"];
			var barPos = item["barPos"];
			var newBarSize = (container[item.client] - item.barTopLimit) *
			item.element[item.client] / item.element[item.scrollSize];
			console.log(item.displayDirection + " , " + container[item.client] + " , " + item.barTopLimit  + " , " + item.element[item.client] + " , " + item.element[item.scrollSize]);
	        // Positioning bar
	        if (isReset || parseInt(scrollerSize, 10) != parseInt(newBarSize, 10)) 
	        {
	            setScrollerSize(item,newBarSize);
	            item["scrollerSize"] = newBarSize;
	        }
	        item["barPos"] = relativeToBarPosition(item,relativePosition(item));
	        if(isSetBarPos)
	        {
	        	setBarPosition(item, item["barPos"]);
	        }
		};
		
		var setBarPosition = function(item,position)
		{
			var scroller = item["scroller"];
			var sendItem = {deltaX:null,deltaY:null};
			sendItem["delta" + item.x] = position - parseInt(scroller.style[item.pos]);
			item.objDrag.setPosition(sendItem.deltaX,sendItem.deltaY);
			var oldPos = scroller.style[item.pos];
	        var newPos = position + "px";
	        if (newPos && newPos != oldPos) 
	        {
	        	scroller.style[item.pos] = newPos;
	        }
		};
		
		var setScrollerSize = function(item,size) 
		{
			var scroller = item["scroller"];
	    	var barMinSize = item.barMinSize || 20;
	    	var newSize = size;
	        if (newSize > 0 && newSize < barMinSize) 
	        {
	        	newSize = barMinSize;
	        }
	        if(scroller) 
	        {
	        	scroller.style[item.size] = parseInt(newSize, 10) + "px";
	        }
	    };
	    
	    var setScrollElementSize = function(item) 
		{
	    	var scrollCss = {};
	    	//console.log(item.displayDirection + " , " + config.element[item.offset] + " , " + config.element[item.scrollSize]);
	    	scrollCss[item.size] = config.element[item.offset] + "px";
	    	util.css(item.element,scrollCss);
	    	var causeCss = {};
	    	if(util.isUndefinedOrNull(item.inputSize) || parseInt(item.inputSize) <= 0)
	    	{
	    		causeCss[item.size] = config.element[item.scrollSize] + "px";
	    	}
	    	else
	    	{
	    		causeCss[item.size] = parseInt(item.inputSize) + "px";
	    	}
	    	util.css(item.scrollableElementCause,causeCss);
		};
	    
	    var relativePosition = function(item,position)
	    {
	    	var size = item.element[item.scrollSize] - item.element[item.client];
	        var newPos;
	        if(position) 
	        {
	        	newPos = scrollableElementPosition(item,position * size);
	        } 
	        else 
	        {
	        	newPos = scrollableElementPosition(item);
	        }
	        return newPos / (size || 1);
	    };
	    
	    var scrollableElementPosition = function(item,x) 
	    { 
	        var ie = "page" + item.x + "Offset";
	        var key = (item.element[ie]) ? ie : item.scroll;
	        if (!util.isUndefined(x)) 
	        {
	        	if(key === item.scroll)
	        	{
	        		setScrollableItems(item,x);
	        	}
	        	else
	        	{
	        		item.element[key] = x;
	        	}
	        }
	        return item.element[key];
	    };
	    
	    var relativeToBarPosition = function(item,pos) 
	    {
	        return pos * getPos(item) + item.barTopLimit;
	    };
	    
	    var barPositionToRelative = function(item,pos) 
	    {
	        return (pos - item.barTopLimit) / getPos(item);
	    };
	    
	    var getPos = function(item)
	    {
	    	return item.container[item.client] - item.barTopLimit - item.scroller[item.offset];
	    };
		
		var addDocumentHandler = function(moveHandler,endHandler)
		{
			if(!documentMouseMoveRef)
			{
				documentMouseMoveRef = moveHandler;
				util.addEvent(document.documentElement,"mousemove",documentMouseMoveRef);
				
			}
			if(!documentMouseUpRef)
			{
				documentMouseUpRef = endHandler;
				util.addEvent(document.documentElement,"mouseup",documentMouseUpRef);
			}
			if(!documentTouchMoveRef)
			{
				documentTouchMoveRef = moveHandler;
				util.addEvent(document.documentElement,"touchmove",documentTouchMoveRef);
				
			}
			if(!documentTouchEndRef)
			{
				documentTouchEndRef = endHandler;
				util.addEvent(document.documentElement,"touchend",documentTouchEndRef);
			}
		};
		
		var removeDocumentHandler = function()
		{
			if(documentMouseMoveRef)
			{
				util.removeEvent(document.documentElement,"mousemove",documentMouseMoveRef);
				documentMouseMoveRef = null;
			}
			if(documentMouseUpRef)
			{
				util.removeEvent(document.documentElement,"mouseup",documentMouseUpRef);
				documentMouseUpRef = null;
			}
			if(documentTouchMoveRef)
			{
				util.removeEvent(document.documentElement,"touchmove",documentTouchMoveRef);
				documentTouchMoveRef = null;
			}
			if(documentTouchEndRef)
			{
				util.removeEvent(document.documentElement,"touchend",documentTouchEndRef);
				documentTouchEndRef = null;
			}
		};
		
		var checkScroll = function(item)
		{
			var scrollContainer = item["scrollContainer"];
			var scroller = item["scroller"];
			var isOverflowing = hasScroll(item);
			if(isOverflowing)
			{
				util.addStyleClass(config.element,"nsScrollerScrollable-" + item.direction);
				util.removeStyleClass(scrollContainer,"nsScrollerHidden");
			}
			else
			{
				util.removeStyleClass(config.element,"nsScrollerScrollable-" + item.direction);
				util.addStyleClass(scrollContainer,"nsScrollerHidden");
			}
		};
		
		var hasScroll = function(item)
		{
			var isOverflowing = item.element[item.client] < item.element[item.scrollSize];
			return isOverflowing;
		};
		
		var updateScrollControls = function()
		{
			var scrollPresent = isBothScrollPresent();
			for(var key in props)
			{
				var item = props[key];
				var scrollContainer = item["scrollContainer"];
				var container = item["container"];
				var scroller = item["scroller"];
				if(scrollPresent)
				{
					util.addStyleClass(scrollContainer,item.containerCSS + "-both");
					util.addStyleClass(scrollContainer,"nsScrollerBarParent" + "-" + item.direction + "-both");
					if(item.buttonAfter)
					{
						util.addStyleClass(item.buttonAfter,item.afterButtonCSS + "-both");
					}
				}
				else
				{
					util.removeStyleClass(scrollContainer,item.containerCSS + "-both");
					util.removeStyleClass(scrollContainer,"nsScrollerBarParent" + "-" + item.direction + "-both");
					if(item.buttonAfter)
					{
						util.removeStyleClass(item.buttonAfter,item.afterButtonCSS + "-both");
					}
				}
			}
			if(scrollPresent)
			{
				util.removeStyleClass(divScrollBarCorner,"nsScrollerHidden");
			}
			else
			{
				util.addStyleClass(divScrollBarCorner,"nsScrollerHidden");
			}
		};
		
		var isBothScrollPresent = function()
		{
			var arrScrollContainer = config.parentElement.querySelectorAll(".nsScrollerContainer");
			var retValue = true;
			for(var count = 0;count < arrScrollContainer.length;count++)
			{
				var scrollContainer = arrScrollContainer[count];
				if(util.hasStyleClass(scrollContainer,"nsScrollerHidden"))
				{
					retValue = false;
				}
			}
			return retValue;
		};
		
		var remove = function()
		{
			removeDocumentHandler();
			util.removeEvent(window,"resize",updateWithDelay);
			clearScroll();
			if(mutationObserver)
			{
				mutationObserver.disconnect();
			}
		};
		
		var dispatchEvent = function(eventType,data,param,bubbles,cancelable)
		{
			util.dispatchEvent(config.element,eventType,data,param,bubbles,cancelable);
		};
		
		var nsScrollerDraggable = function(setting)
		{
			var self = this;
			var util = null;
			var config = {};
			var objVar = {};
			var documentMouseMoveRef = null;
			var documentMouseUpRef = null;
			var documentTouchMoveRef = null;
			var documentTouchEndRef = null;
			
			var initialize = function()
			{
				util = new NSUtil();
				if(!setting)
				{
					setting = {};
				}
				config = {
						element: setting["element"],
						restriction: setting["restriction"],
						enableXAxis: util.isUndefinedOrNull(setting["enableXAxis"]) ? true : Boolean.parse(setting["enableXAxis"]),
						enableYAxis: util.isUndefinedOrNull(setting["enableYAxis"]) ? true : Boolean.parse(setting["enableYAxis"]),
						xBoundaryElement: setting["xBoundaryElement"],
						yBoundaryElement: setting["yBoundaryElement"],
						context: setting["context"] || window,
						document: setting["document"] || document,
						body: setting["body"] || document.body,
				};
				if(!config.element)
				{
					util.throwNSError("NSScrollerDraggable","Element in setting is missing");
				}
				config.dragStartingCallback = util.getFunction(setting["dragStartingCallback"],config.context);
				config.draggingCallback = util.getFunction(setting["draggingCallback"],config.context);
				config.dragEndCallback = util.getFunction(setting["dragEndCallback"],config.context);
				
				if(config.restriction == "parent")
				{
					config.xBoundaryElement = config.element.parentNode;
					config.yBoundaryElement = config.element.parentNode;
				}
				var position = util.getStyleValue(config.element,"position",true);
				if(position != "relative" && position != "absolute")
				{
					config.element.style.position = "relative";
				}
				config.element.style.top = "0px";
				config.element.style.left = "0px";
				util.addEvent(config.element,"mousedown",elementMouseDownHandler);
			};
			
			var elementMouseDownHandler = function(event)
			{
				event = util.getEvent(event);
				objVar.dragging = true;
				var rect = config.element.getBoundingClientRect();
				objVar.initX = event.clientX - rect.left;
				objVar.initY = event.clientY - rect.top;

				objVar.initLeft = config.element.style.left;
				objVar.initTop = config.element.style.top;
				selection(false);
				addDocumentHandler();
				if(config.dragStartingCallback)
				{
					config.dragStartingCallback(event,config.element);
				}
			};
			
			var windowMouseMoveHandler = function(event)
			{
				if(objVar.dragging)
				{
					event = util.getEvent(event);
					var rect = config.element.getBoundingClientRect();
					var deltaX = event.clientX - (objVar.initX + rect.left);
					var deltaY = event.clientY - (objVar.initY + rect.top);
					setElementPos(deltaX,deltaY);
					if(config.draggingCallback)
					{
						config.draggingCallback(event,config.element);
					}
				}
			};
			
			var windowMouseUpHandler = function(event)
			{
				if (objVar.dragging) 
				{
					event = util.getEvent(event);
					complete(event);
					release();
				}
				removeDocumentHandler();
			};
			
			var windowKeyDownHandler = function(event)
			{
				event = util.getEvent(event);
				if (event.key === "Escape" && objVar.dragging) 
				{
					cancel();
					release();
				}
			};
			
			var setElementPos = function(deltaX,deltaY)
			{
				var rect = config.element.getBoundingClientRect();
				if (config.enableXAxis) 
				{
					var newLeft = parseInt(config.element.style.left) + deltaX;
					if (config.xBoundaryElement) 
					{
						var boundaryRect = config.xBoundaryElement.getBoundingClientRect();
						var dragDestination = rect.left + deltaX;
						var notPastLeft = dragDestination >= boundaryRect.left;
						var notPastRight = dragDestination <= (boundaryRect.right - rect.width);
						
						if (notPastLeft && notPastRight) 
						{
							config.element.style.left = newLeft + "px";
						} 
						else if (!notPastLeft) 
						{
							config.element.style.left = newLeft - (dragDestination - boundaryRect.left) + "px";
						} 
						else if (!notPastRight) 
						{
							config.element.style.left = newLeft - (dragDestination - boundaryRect.right + rect.width) + "px";
						}
					}
					else 
					{
						config.element.style.left = newLeft + "px";
					}
				}
				if (config.enableYAxis) 
				{
					var newTop = parseInt(config.element.style.top) + deltaY;
					if (config.yBoundaryElement) 
					{
						var boundaryRect = config.yBoundaryElement.getBoundingClientRect();
						var dragDestination = rect.top + deltaY;
						var notPastTop = dragDestination >= boundaryRect.top;
						var notPastBottom = dragDestination <= (boundaryRect.bottom - rect.height);

						if (notPastTop && notPastBottom) 
						{
							config.element.style.top = newTop + "px";
						} 
						else if (!notPastTop) 
						{
							config.element.style.top = newTop - (dragDestination - boundaryRect.top) + "px";
						} 
						else if (!notPastBottom) 
						{
							config.element.style.top = newTop - (dragDestination - boundaryRect.bottom + rect.height) + "px";
						}
					} 
					else 
					{
						config.element.style.top = newTop + "px";
					}
				}
			};
			
			var selection = function(enable)
			{
				var setProp = function(value)
				{
					config.body.style.userSelect = value;
					config.body.style.webkitUserSelect = value;
					config.body.style.mozUserSelect = value;
					config.body.style.msUserSelect = value;
				};
				if(enable)
				{
					util.removeEvent(config.document,"selectpos",disableSelectionHandler);
					util.removeEvent(config.document,"selectstart",disableSelectionHandler);
					setProp("");
				}
				else
				{
					util.addEvent(config.document,"selectpos",disableSelectionHandler);
					util.addEvent(config.document,"selectstart",disableSelectionHandler);	
					setProp("none");
				}
			};
			
			var disableSelectionHandler = function(event)
			{
				event = util.getEvent(event);
				event.preventDefault();
			};
			
			var addDocumentHandler = function()
			{
				if(!documentMouseMoveRef)
				{
					documentMouseMoveRef = windowMouseMoveHandler;
					util.addEvent(config.context,"mousemove",documentMouseMoveRef);
					
				}
				if(!documentMouseUpRef)
				{
					documentMouseUpRef = windowMouseUpHandler;
					util.addEvent(config.context,"mouseup",documentMouseUpRef);
				}
				if(!documentTouchMoveRef)
				{
					documentTouchMoveRef = windowMouseMoveHandler;
					util.addEvent(config.context,"touchmove",documentTouchMoveRef);
					
				}
				if(!documentTouchEndRef)
				{
					documentTouchEndRef = windowMouseUpHandler;
					util.addEvent(config.context,"touchend",documentTouchEndRef);
				}
			};
			
			var removeDocumentHandler = function()
			{
				if(documentMouseMoveRef)
				{
					util.removeEvent(config.context,"mousemove",documentMouseMoveRef);
					documentMouseMoveRef = null;
				}
				if(documentMouseUpRef)
				{
					util.removeEvent(config.context,"mouseup",documentMouseUpRef);
					documentMouseUpRef = null;
				}
				if(documentTouchMoveRef)
				{
					util.removeEvent(config.context,"touchmove",documentTouchMoveRef);
					documentTouchMoveRef = null;
				}
				if(documentTouchEndRef)
				{
					util.removeEvent(config.context,"touchend",documentTouchEndRef);
					documentTouchEndRef = null;
				}
			};
			
			var release = function()
			{
				selection(true);
				objVar = {};
			};
			
			var complete = function(event) 
			{
				if(config.dragEndCallback)
				{
					config.dragEndCallback(event,config.element);
				}
			};

			var cancel = function() 
			{
				config.element.style.left = objVar.initLeft;
				config.element.style.top = objVar.initTop;
			};
			
			var remove = function()
			{
				util.removeEvent(config.element,"mousedown",elementMouseDownHandler);
				removeDocumentHandler();
			};
			
			var setPosition = function(deltaX,deltaY)
			{
				setElementPos(deltaX,deltaY);
			};
			
			self.setPosition = setPosition;
			self.remove = remove;
			
			initialize();
		};
		
		self.setScrollWidth = setScrollWidth;
		self.setScrollHeight = setScrollHeight;
		self.setScrollTop = setScrollTop;
		self.getScrollTop = getScrollTop;
		self.setScrollLeft = setScrollLeft;
		self.getScrollLeft = getScrollLeft;
		self.getVerticalScrollHeight = getVerticalScrollHeight;
		self.getHorizontalScrollWidth = getHorizontalScrollWidth;
		self.hasHorizontalScroller = hasHorizontalScroller;
		self.hasVerticalScroller = hasVerticalScroller;
		self.getHorizontalScroller = getHorizontalScroller;
		self.getVerticalScroller = getVerticalScroller;
		self.getHorizontalBar = getHorizontalBar;
		self.getVertcialBar = getVertcialBar;
		self.remove = remove;
		
		NSScroller.SCROLL_START = "scrollStart";
		NSScroller.SCROLLING = "scrolling";
		NSScroller.SCROLL_END = "scrollEnd";
		
		initialize();
	};
	
	return NSScroller;
})();
nsModuleExport(this,"NSScroller",NSScroller);
