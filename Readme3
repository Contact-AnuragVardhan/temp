this.__columnSortable = true;
if(this.hasAttribute("columnSortable"))
			{
				this.__columnSortable = Boolean.parse(this.getAttribute("columnSortable"));
			}
      if(this.__columnSortable)
			{
				objColumn["sortable"] = this.util.isUndefinedOrNull(objColumn["sortable"]) ? true : Boolean.parse(objColumn["sortable"]);
			}
      
      this.isOtherKeyNavigationValid = function(event,cell)
		{
			var hasFocus = false;
			if(this.__config.editType == NSGrid.EDITOR_EDITTYPE_CELL)
			{
				hasFocus = this.__hasCellFocus(cell);
			}
			else
			{
				var row = this.util.findParent(cell,"TR");
				hasFocus = this.__hasRowFocus(row);
			}
			return !hasFocus;
		};
    
    this.__hasRowFocus = function(row)
		{
			if(row)
			{
				var arrEditor = this.__getOnlyEditors(row);
				if(arrEditor && arrEditor.length > 0)
				{
					for(var count = 0;count < arrEditor.length;count++)
					{
						var hasFocus = this.__hasCellFocus(null,arrEditor[count]);
						if(hasFocus)
						{
							return true;
						}
					}
					var activeElement = document.activeElement;
					if(activeElement)
					{
						var activeRow = this.util.findParent(activeElement,"TR");
						if(activeRow && activeRow == row)
						{
							return true;
						}
					}
				}
			}
			return false;
		};
    
    
    checkCellFocus = Boolean.parse(checkCellFocus);
				if(!checkCellFocus || this.__hasCellFocus(null,editor))
				{
					var retValue = null;
					/*var config = editor[this.__getAttributeKey("config")];
					if(config)
					{
						console.log(config.column.dataField + " :: " + config.item[config.column.dataField]);
					}*/
          
          
          firstDate = this.__convertToDate(firstDateString);
		    	  secondDate = this.__convertToDate(secondDateString);
		    	  if(sortAscending)
		    	  {
		    		  if (firstDate > secondDate) 
		    		  {
		    			  return 1;
		    		  }
		    		  if (firstDate < secondDate)
		    		  {
		    			  return -1;
		    		  }
		    		  return 0;
		    	  }
		    	  else
		    	  {
		    		  if (firstDate > secondDate) 
		    		  {
		    			  return -1;
		    		  }
		    		  if (firstDate < secondDate)
		    		  {
		    			  return 1;
		    		  }
		    		  return 0;
		    	  }
            
            this.__isDate = function(value) 
		{
			if (Object.prototype.toString.call(value) === '[object Date]') 
			{
				return true;
			}
			if (typeof value.replace === 'function') 
			{
			    value.replace(/^\s+|\s+$/gm, '');
			}
			var dateFormat = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/;
			var retValue = dateFormat.test(value);
			if(!retValue)
			{
				value = this.__formatDateString(value);
				var parsedDate = Date.parse(value);
				if (isNaN(value) && !isNaN(parsedDate)) 
				{
					retValue = true;
				}
			}
			return retValue;
		};
		
		this.__convertToDate = function(value) 
		{
			var retValue = null;
			if(!this.util.isUndefinedOrNull(value))
		    {
				value = this.__formatDateString(value);
				retValue = new Date(value);
		    }
		    return retValue;
		};
		
		this.__formatDateString = function(value)
		{
			if(this.util.isString(value))
		    {
				//For consitions where date comes like (from sqlserver convert(varchar,date,100)) "May 16 2016  2:25PM" 
				//then new Date returns nan.It should be like "May 16 2016  2:25 PM"
				var ampm = null;
				ampm = ((value.indexOf("AM") > -1) ? "AM" : ((value.indexOf("PM") > -1) ? "PM" : null));
				if(ampm)
				{
					var index = value.indexOf(ampm);
					if(value.charAt(index-1) != " ")
					{
						value = value.substring(0,index) + " " + ampm;
					}
				}
		    }
			return value;
		};
		
