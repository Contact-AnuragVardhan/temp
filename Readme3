var XlsxWorkbook = function(util,styles,sharedString,arrSheets)
		{
			var self = this;
			var arrSheet = [];
			
			var process = function() 
			{
				arrSheet = [];
				var sheetValue = "";
				if(arrSheets && arrSheets.length > 0)
				{
					for(var count = 0;count < arrSheets.length;count++)
					{
						var sheetID = count + 1;
						var sheet = new XlsxSheet(util,self,styles,sharedString,arrSheets[count],sheetID);
						sheetValue += sheet.process();
						arrSheet.push(sheet);
					}
				}
				sheetValue = '<sheets>' + sheetValue + '</sheets>';
				return util.getXML({
					name: 'workbook',
					ns: 'spreadsheetml',
					attributes: {'xmlns:r': util.schemas.r,'xmlns:mx': util.schemas.mx,'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: ['<workbookPr/>','<bookViews><workbookView activeTab="0"/></bookViews>', sheetValue, '<definedNames/>', '<calcPr/>']
				});
			};
			
			var getSheet = function(index)
			{
				if(arrSheet && arrSheet.length > index)
				{
					return arrSheet[index];
				}
				return null;
			};
			
			self.process = process;
			self.getSheet = getSheet;
		};
		
		var XlsxSheet = function(util,xlsxWorkbook,styles,sharedString,objSheet,sheetIndex)
		{
			var self = this;
			var arrRow = [];
			var sheetData = null;
			var path = null;
			var relationsPath = null;
			var relationship = null;
			var override = null;
			var maxX = 0;
			var maxY = null;
			var isHeaderRequired = false;
			var arrProcessColumns = [];
			var objProcessRows = {};
			var arrProcessData = [];
			var mergedCells = null;
			
			var initialize = function()
			{
				mergedCells = new XlsxMergedCells(util,self);
				getObjColumns();
				getObjRows();
				getData();
			};
			
			var getObjColumns = function()
			{
				var arrCol = objSheet.columns;
				for(var index in arrCol)
				{
					var column = util.cloneObject(arrCol[index]);
					if(column.headerText)
					{
						isHeaderRequired = true;
					}
					if (column.style) 
					{
						column.style = styles.addFormat(column.style);
						var style = styles.addFillOutFormat(column.style);
						item.styleID = styles.getStyleID(style);
					}
					arrProcessColumns.push(column);
				}
			};
			
			var getObjRows = function()
			{
				var objRows = objSheet.rowProperties;
				var dataIndex = 0;
				var setStyle = function(tempRow,tempStyle)
				{
					tempRow.style = styles.addFormat(tempStyle);
					var rowStyle = styles.addFillOutFormat(tempRow.style);
					tempRow.styleID = styles.getStyleID(rowStyle);
				};
				if(objSheet.title)
				{
					var item = {};
					var titleStyle = {horizontal: 'center',vertical: 'center',font: {bold: true}};
					if(objSheet.titleStyle)
					{
						titleStyle = objSheet.titleStyle;
					}
					setStyle(item,titleStyle);
					item.skipColumnsStyle = true;
					item.type = "string";
					objProcessRows[dataIndex++] = item;
				}
				if(isHeaderRequired)
				{
					var item = {};
					if(objSheet.headerStyle)
					{
						setStyle(item,objSheet.headerStyle);
						item.skipColumnsStyle = true;
					}
					else
					{
						item.skipColumnsStyle = false;
					}
					item.type = "string";
					objProcessRows[dataIndex++] = item;
				}
				for(var key in objRows)
				{
					var row = util.cloneObject(objRows[key]);
					if (row.style) 
					{
						setStyle(row,row.style);
					}
					row.skipColumnsStyle = row.skipColumnsStyle || false;
					var index = parseInt(key) + dataIndex;
					objProcessRows[index] = row;
				}
			};
			
			var getData = function()
			{
				var dataSource = objSheet.dataSource;
				var tempSource = [];
				var dataIndex = 0;
				if(objSheet.title)
				{
					var item = util.getArrayOfSize(arrProcessColumns.length,function(index){
						if(index == 0)
						{
							return {value: objSheet.title, colspan:arrProcessColumns.length};
						}
						return {value: null};
					});
					tempSource.push(item);
					dataIndex++;
				}
				if(isHeaderRequired)
				{
					var item = [];
					for(var index in arrProcessColumns)
					{
						var column = arrProcessColumns[index];
						item.push(column.headerText || "");
					}
					tempSource.push(item);
					dataIndex++;
				}
				var source = tempSource.concat(dataSource); 
				for(var index in source)
				{
					var rowData = source[index];
					var objRow = objProcessRows[index] || {};
					var rowIndex = parseInt(index) + 1;
					var row = getRowData(rowData,objRow,rowIndex,source);
					arrProcessData.push(row);
					//maxX = Math.max(maxX, row.length);
				}
				
				maxY = arrProcessData.length;
			};
			
			var getRowData = function(rowData,objRow,rowIndex,dataSource)
			{
				var retValue = [];
				if(rowData)
				{
					var rowStyle = null;
					var skipColumnsStyle = false;
					var inserts = [];
					if (!util.isArray(rowData)) 
					{
						rowData = mergeRowDataToRow(rowData,objRow);
					}
					if(rowData)
					{
						rowStyle = rowData.style || null;
						skipColumnsStyle = rowData.skipColumnsStyle;
					}
					for(var index in arrProcessColumns)
					{
						var objCol = arrProcessColumns[index];
						var objCell = getCellDetails(rowData,objCol,index);
						objCol["cellDetails"] = objCol["cellDetails"] || {};
						objCol["cellDetails"][rowIndex] = objCell;
						if(objCell.isObject)
						{
							if(objCell.isSpanRequired)
							{
								rowData = mergeCells(dataSource,rowData,arrProcessColumns,parseInt(index),rowIndex - 1,objCell);
							}
						}
					}
				}
				
				return rowData;
			};
			
			var mergeRowDataToRow = function(rowData,objRow)
			{
				rowData.height = rowData.height || objRow.height;
				rowData.outlineLevel = rowData.outlineLevel || objRow.outlineLevel;
				rowData.type = rowData.type || objRow.type;
				rowData.style = rowData.style ? styles.addFormat(rowData.style) : objRow.style;
				rowData.skipColumnsStyle = rowData.skipColumnsStyle || objRow.skipColumnsStyle;

				return rowData;
			};
			
			var getCellDetails = function(rowData,objCol,index)
			{
				var value = util.isArray(rowData) ? rowData[index] : rowData[objCol.dataField];
				var retValue = {origValue: value, value: value,isObject: false,style: null,isSpanRequired: false};
				if (value !== undefined && !util.isDate(value) && util.isObject(value))
				{
					retValue.isObject = true;
					if (value.style) 
					{
						retValue.style = value.style;
					}
					if (value.colspan || value.rowspan) 
					{
						retValue.isSpanRequired = true;
					}
					retValue.value = value.value;
				}
				
				return retValue;
			};
			
			var mergeCells = function(dataSource,rowData,arrCol,colIndex,rowIndex,objCell)
			{
				var origValue = objCell.origValue;
				if (origValue.colspan || origValue.rowspan) 
				{
					var colSpan = (origValue.colspan || 1) - 1;
					var rowSpan = (origValue.rowspan || 1) - 1;
					if (colSpan || rowSpan) 
					{
						mergedCells.addMergedCells({ c: colIndex + 1, r: rowIndex + 1 }, { c: colIndex + 1 + colSpan, r: rowIndex + 1 + rowSpan });
						return mergedCells.add(dataSource,rowData,arrCol,colIndex,rowIndex,colSpan,rowSpan,origValue.style);
					}
				}
				return rowData;
			};
			
			var process = function() 
			{
				sheetData = processSheetData();
				setProp();
				return processSheet();
			};
			
			var processSheetData = function() 
			{
				arrRow = [];
				var rowValue = "";
				var colValue = "";
				if(objSheet)
				{
					colValue = processColumns(arrProcessColumns);
					if(arrProcessColumns && arrProcessColumns.length > 0 && arrProcessData && arrProcessData.length > 0)
					{
						for(var count = 0;count < arrProcessData.length;count++)
						{
							var rowIndex = count + 1;
							var objRow = objProcessRows[count] || {};
							var row = new XlsxRow(util,self,styles,sharedString,arrProcessData[count],arrProcessColumns,rowIndex,objRow);
							rowValue += row.process();
							arrRow.push(row);
						}
					}
				}
				rowValue = '<sheetData>' + rowValue + '</sheetData>';
				rowValue += getAfterSheetData();
				
				return util.getXML({
					name: 'worksheet',
					ns: 'spreadsheetml',
					attributes: {'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:mx': util.schemas.mx,'xmlns:r': util.schemas.r,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: [colValue,rowValue]
				});
			};
			
			var getAfterSheetData = function()
			{
				var retValue = "";
				retValue += mergedCells.getTag();
				return retValue;
			};
			
			var processSheet = function() 
			{
				var templateSheet = '<sheet state="visible" name="###sheetName###" sheetId="###sheetIndex###" r:id="rId###sheetIndex###"/>';
				var sheet = templateSheet.replaceAll("###sheetName###",objSheet.name || ("Sheet" + sheetIndex));
				sheet = sheet.replaceAll("###sheetIndex###",sheetIndex);
				return sheet;
			};
			
			var processColumns = function(arrCol)
			{
				if(arrCol && arrCol.length > 0)
				{
					var arrChildren = [];
					for(var count = 0;count < arrCol.length;count++)
					{
						var item = arrCol[count];
						var arrAttr = {'min': item.min || count + 1, 'max': item.max || count + 1};
						if (item.hidden) 
						{
							arrAttr['hidden'] = 1;
						}
						if (item.autoFit) 
						{
							arrAttr['bestFit'] = 1;
						}
						if (item.width) 
						{
							arrAttr['customWidth'] = 1;
							arrAttr['width'] = item.width;
						} 
						else 
						{
							arrAttr['width'] = 9.140625;
						}
						if (item.styleID) 
						{
							arrAttr['style'] = item.styleID;
						}
						arrChildren.push(util.getXML({
							name: 'col',
							attributes: arrAttr
						}));
					}
					return util.getXML({
						name: 'cols',
						children: arrChildren
					});
				}
				return '';
			};
			
			var getRow = function(index)
			{
				if(arrRow && arrRow.length > index)
				{
					return arrRow[index];
				}
				return null;
			};
			
			var setProp = function()
			{
				path = 'worksheets/sheet' + sheetIndex + '.xml';
				relationsPath = 'worksheets/_rels/sheet' + sheetIndex + '.xml.rels';
				relationship = util.getXML({
					name: 'Relationship',
					attributes: {'Id': 'rId' + sheetIndex,'Type': util.schemas.worksheet,'Target': path}
				});
				override = util.getXML({
					name: 'Override',
					attributes: {'PartName': '/xl/' + path,'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'}
				});
			};
			
			var getPath = function()
			{
				return path;
			};
			
			var getRelationsPath = function()
			{
				return relationsPath;
			};
			
			var getSheetData = function()
			{
				return sheetData;
			};
			
			var getRelationship = function()
			{
				return relationship;
			};
			
			var getOverride = function()
			{
				return override;
			};
			
			initialize();
			
			self.process = process;
			self.getRow = getRow;
			self.setProp = setProp;
			self.getPath = getPath;
			self.getRelationsPath = getRelationsPath;
			self.getSheetData = getSheetData;
			self.getRelationship = getRelationship;
			self.getOverride = getOverride;
			self.getCellDetails = getCellDetails;
		};
		
		var XlsxRow = function(util,xlsxSheet,styles,sharedString,rowData,arrCol,rowIndex,objRow)
		{
			var self = this;
			var arrCell = [];
			
			var process = function() 
			{
				arrCell = [];
				var cellValue = "";
				if(arrCol && arrCol.length > 0)
				{
					for(var count = 0;count < arrCol.length;count++)
					{
						var objCol = arrCol[count];
						var objCell = objCol["cellDetails"][rowIndex] || xlsxSheet.getCellDetails(rowData,objCol,count);
						var cell = new XlsxCell(util,self,styles,sharedString,objCol,count + 1,rowData,rowIndex,objCell,objRow,objRow.skipColumnsStyle);
						cellValue += cell.process();
						arrCell.push(cell);
					}
				}
				return util.getXML({
					name: 'row',
					attributes: getAttr(),
					children: [cellValue]
				});
			};
			
			var getAttr = function()
			{
				var attr = {'r': rowIndex};
				if (objRow.height !== undefined) 
				{
					attr["customHeight"] = 1;
					attr["ht"] = objRow.height;
				}
				if (objRow.styleID) 
				{
					attr["customFormat"] = 1;
					attr["s"] = objRow.styleID;
				}
				if (objRow.outlineLevel) 
				{
					attr["outlineLevel"] = objRow.outlineLevel;
				}
				return attr;
			};
			
			var getCell = function(index)
			{
				if(arrCell && arrCell.length > index)
				{
					return arrCell[index];
				}
				return null;
			};
			
			self.process = process;
			self.getCell = getCell;
			
		};
		
		var XlsxCell = function(util,xlsxRow,styles,sharedString,objCol,cellIndex,rowData,rowIndex,objCell,objRow,skipColumnsStyle)
		{
			var self = this;
			var dataType = null;
			
			initialize = function()
			{
				
			};
			
			var process = function() 
			{
				var value = objCell.value;
				var cellStyle = objCell.style;
				var objValue = objCell.origValue;
				var cellType = getCellType(value);
				var predefinedStyle = null;
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						predefinedStyle = cellType;
						break;
					}
				}
				var columnStyle = !skipColumnsStyle ? objCol.style : null;
				var rowStyle = objRow.style;
				var finalCellStyleID = styles.getStyleID(styles.merge(predefinedStyle,columnStyle,rowStyle,cellStyle));
				var objCellValue = getCellObj(cellType,value);
				var attributes = getAttr(cellIndex - 1,rowIndex,cellType,finalCellStyleID);
				var children = "";
				if (objCellValue.formula != undefined && objCellValue.formula != null) 
				{
					children = '<v>' + objCellValue.formula + '</v>';
				}
				else if (objCellValue.value != undefined && objCellValue.value != null) 
				{
					/*if(cellType == "string")
					{
						children = '<is><t>' + objCellValue.value + '</t></is>';
					}
					else
					{*/
						children = '<v>' + objCellValue.value + '</v>';
					//}
				}
				return util.getXML({
					name: 'c',
					attributes: attributes,
					children: [children]
				});
			};
			
			var getAttr = function(index,rowIndex,cellType,styleID)
			{
				var attr = {'r': generatorCellNumber(index, rowIndex)};
				if (styleID) 
				{
					attr["s"] = styleID;
				}
				switch (cellType)
				{
					case "string":
						//attr["t"] = "inlineStr";
						attr["t"] = "s"; 
					break;
					case "boolean":
						attr["t"] = "b"; 
					break;
				}
				return attr;
			};
			
			var getCellType = function(value)
			{
				if(objCell && objCell.type)
				{
					return objCell.type;
				}
				else if (rowData && rowData.type) 
				{
					return rowData.type;
				}
				else if (objRow && objRow.type) 
				{
					return objRow.type;
				}
				if(objCol && objCol.type)
				{
					return objCol.type;
				}
				else if (typeof value === 'number') 
				{
					return 'number';
				} 
				else if (typeof value === 'string') 
				{
					return 'string';
				}
				else if(util.isDate(value))
				{
					return "date";
				}
				return 'string';
			};
			
			var getCellObj = function(cellType,cellValue) 
			{
				var retValue = {value: null,formula: null,isString: false};
				
				var formulaFunc = function(objRet,value,sharedString)
				{
					objRet.formula = util.escapeString(value);
					return objRet;
				};
				
				var stringFunc = function(objRet,value,sharedString)
				{
					objRet.value = sharedString.add(value);
					//objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				
				var mapCellType = {string: {func: stringFunc},
								   formula:{func: formulaFunc}};
				for(var key in mapCellType)
				{
					if(cellType == key)
					{
						return mapCellType[key].func(retValue,cellValue,sharedString);
					}
				}
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						return util.numberPredifined[key].cellObjFunc(retValue,cellValue,sharedString);
					}
				}
				retValue.value = cellValue;
				return retValue;
			};
			
			var generatorCellNumber = function(index, rowNumber)
			{
				return generateColumnLetter(index) + rowNumber;
			};
			
			var generateColumnLetter = function(colIndex) 
			{
				if (typeof colIndex !== 'number') 
				{
					return '';
				}
				var prefix = Math.floor(colIndex / 26);
				var letter = String.fromCharCode(97 + (colIndex % 26)).toUpperCase();
				if (prefix === 0) 
				{
					return letter;
				}
				return generateColumnLetter(prefix - 1) + letter;
			};
			
			initialize();
			
			self.process = process;
		};
		
		var XlsxSharedStrings = function(util)
		{
			var self = this;
			var objString = {};
			var arrString = [];
			var index = 0;
			var regexSpace = /^\s|\s$/;
			
			var add = function(str) 
			{
				var strIndex = objString[str];
				if (strIndex === undefined) 
				{
					strIndex = index++;
					objString = strIndex;
					arrString[strIndex] = str;
				}
				return strIndex;
			};
			
			var getAllString = function()
			{
				return arrString;
			};
			
			var hasString = function()
			{
				return index > 0;
			};
			
			var getTag = function()
			{
				var strResult = "";
				for(var index in arrString)
				{
					var str = util.escapeString(arrString[index]);
					if (regexSpace.test(str)) 
					{
						strResult += '<si><t xml:space="preserve">' + str + '</t></si>';
					}
					else
					{
						strResult += '<si><t>' + str + '</t></si>';
					}
				}
				var retValue = getTagStart(index) + strResult + getTagEnd();
				reset();
				return retValue;
			};
			
			var getTagStart = function(count) 
			{
				return util.xmlPrefix + '<sst xmlns="' + util.schemas.spreadsheetml + '" count="' + count + '" uniqueCount="' + count + '">';
			};

			var getTagEnd = function() 
			{
				return '</sst>';
			};
			
			var reset = function()
			{
				objString = {};
				arrString = [];
				//not setting index as 0 so that while saving other api can figure out that shared String exists
				//index = 0;
			};
			
			self.add = add;
			self.getAllString = getAllString;
			self.getTag = getTag;
			self.hasString = hasString;
		};
		
		var XlsxMergedCells = function(util,sheet)
		{
			var self = this;
			var arrCells = [];
			
			var add = function(dataSource,rowData,arrCol,colIndex,rowIndex,colSpan,rowSpan,style)
			{
				if(colSpan)
				{
					var getEmptyCell = function(index)
					{
						return {value: null,style: style};
					};
					if(!util.isArray(rowData))
					{
						rowData = convertObjectToArray(rowData,arrCol);
					}
					var arrTill = copyArray(rowData.slice(0, colIndex + 1));
					var arrEmpty = util.getArrayOfSize(colSpan,getEmptyCell);
					arrEmpty = copyArray(arrEmpty);
					var arrAfter = copyArray(rowData.slice(colIndex + 1));
					rowData = [].concat(arrTill,arrEmpty,arrAfter);
				}
				if(rowSpan) 
				{
					var index = 1;
					for(var count = (rowIndex + 1);(count < dataSource.length && index < rowSpan);count++)
					{
						var item = dataSource[count];
						util.isArray(item) ? (item[colIndex] = "") : (item[arrCol[colIndex].dataField] = null);
						index++;
					}
					while(index < rowSpan)
					{
						var item = {};
						for(var count = 0;count < arrCol.length;count++)
						{
							if(count == colIndex)
							{
								item[arrCol[colIndex].dataField] = {style: style,value: null};
							}
							else
							{
								item[arrCol[colIndex].dataField] = null;
							}
						}
						dataSource.push(item);
						index++;
					}
				}
				
				return rowData;
			};
			
			var addMergedCells = function(fromCell,toCell) 
			{
				arrCells.push([fromCell, toCell]);
			};
			
			var getTag = function()
			{
				if (arrCells.length > 0) 
				{
					var arrChildren = [];
					for(var index in arrCells)
					{
						var mergeCell = arrCells[index];
						arrChildren.push(util.getXML({
							name: 'mergeCell',
							attributes: {'ref': util.getCanonCell(mergeCell[0]) + ':' + util.getCanonCell(mergeCell[1])}
						}));
					}
					return util.getXML({
						name: 'mergeCells',
						attributes: {'count': arrCells.length},
						children: arrChildren
					});
				}
			};
			
			var convertObjectToArray = function(rowData,arrCol)
			{
				var retValue = Array(arrCol.length);
				for(var count = 0;count < arrCol.length;count++)
				{
					var objCol = arrCol[count];
					retValue[count] = rowData[objCol.dataField];
				}
				return retValue;
			};
			
			var copyArray = function(arrSource)
			{
				if (util.isArray(arrSource)) 
				{
					var retValue = Array(arrSource.length);
					for (var i = 0; i < arrSource.length; i++) 
					{ 
						retValue[i] = arrSource[i]; 
					} 
					return retValue; 
				} 
				return Array.from(arrSource); 
			};
			
			self.add = add;
			self.addMergedCells = addMergedCells;
			self.getTag = getTag;
		};
		
		var XlsxUtil = function()
		{
			var self = this;
			var objSheetsProp = {};
			
			var xmlPrefix = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
			var schemas = {
					'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
					'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',
					'mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
					'mv': 'urn:schemas-microsoft-com:mac:vml',
					'x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
					'x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
					'xm': 'http://schemas.microsoft.com/office/excel/2006/main',
					'spreadsheetml': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
					'relationshipPackage': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'worksheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
					'stylesheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
					'sharedStrings': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
					'contentTypes': 'http://schemas.openxmlformats.org/package/2006/content-types',
					
					'officeDocument': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
					'package': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'table': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
					'spreadsheetDrawing': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
					'drawing': 'http://schemas.openxmlformats.org/drawingml/2006/main',
					'drawingRelationship': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
					'image': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
					'chart': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
					'hyperlink': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink'
			};
			var numberPredifined = null;
			
			var initialize = function()
			{
				var getDateTimeCellObj = function(objRet,value,sharedString)
				{
					var date = getDateTimeValue(value);
					if(date)
					{
						objRet.value = date;
					}
					else
					{
						objRet.value = sharedString.add(String(value));
						//objRet.value = value;
						objRet.isString = true;
					}
					return objRet;
				};
				var getNumberCellObj = function(objRet,value,sharedString)
				{
					objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				numberPredifined = {
						date: {formatId: 14,cellObjFunc:getDateTimeCellObj}, //mm-dd-yy
						time: {formatId: 21,cellObjFunc:getDateTimeCellObj}, //h:mm:ss
						integer: {formatId: 1,cellObjFunc:getNumberCellObj},
						double: {formatId: 2,cellObjFunc:getNumberCellObj}
				};
			};
			
			var getXML = function(config) 
			{
				var retValue = '<' + config.name;
				var content = '';

				if (config.ns) 
				{
					retValue = xmlPrefix + retValue + ' xmlns="' + schemas[config.ns] + '"';
				}
				if (config.attributes) 
				{
					for(var key in config.attributes)
					{
						retValue += ' ' + key + '="' + escapeString(config.attributes[key]) + '"';
					}
				}
				if (config.value !== undefined) 
				{
					content += escapeString(config.value);
				}
				if (config.children) 
				{
					content += config.children.join('');
				}
				if (content) 
				{
					retValue += '>' + content + '</' + config.name + '>';
				} 
				else 
				{
					retValue += '/>';
				}
				return retValue;
			};
			
			var escapeString = function(str)
			{
				return str;
			};
			
			var addSheetProp = function(prop,value)
			{
				objSheetsProp[prop] = objSheetsProp[prop] ? (objSheetsProp[prop] + " " + value) : value;
			};
			
			var getSheetProp = function(prop)
			{
				return objSheetsProp[prop];
			};
			
			var getCanonColor = function(color) 
			{
				return color[0] === '#' ? 'FF' + color.substr(1) : color;
			};
			
			var getColorTag = function(color) 
			{
				if (isString(color)) 
				{
					return getXML({
						name: 'color',
						attributes: {'rgb': getCanonColor(color)}
					});
				} 
				else 
				{
					var attributes = {};
					if (color.tint) 
					{
						attributes['tint'] = color.tint;
					}
					if (color.auto) 
					{
						attributes['auto'] = !!color.auto;
					}
					if (color.theme) 
					{
						attributes['theme'] = color.theme;
					}
					return getXML({
						name: 'color',
						attributes: attributes
					});
				}
			};
			
			var hasInArray = function(arrSource,value)
			{
				 return (arrSource.indexOf(value) > -1);
			};
			
			var isObject = function(refObject)
			{
				if (typeof refObject === 'object' && refObject !== null) 
				{
				    return true;
				} 
				return false;
			};
			
			var isString = function(object) 
			{
			    return typeof object == "string";
			};
			
			var isDate = function(object) 
			{
				return (Object.prototype.toString.call(object) === "[object Date]"); 
			};
			
			var isArray = function(object)
			{
				return Array.isArray(object);
			};
			
			var isObjectEmpty = function(obj)
			{
				for(var key in obj) 
				{
			        if(obj.hasOwnProperty(key))
			        {
			        	return false;
			        }
			    }
			    return true;
			};
			
			var getDateTimeValue = function(value)
			{
				var timezoneOffset = new Date().getTimezoneOffset() * 60 * 1000;
				var dateValue = isDate(value) ? value.valueOf() : value;
				var date = 25569.0 + (dateValue - timezoneOffset) / (60 * 60 * 24 * 1000);
				if (isFinite(date)) 
				{
					return date;
				}
				return null;
			};
			
			var cloneObject = function(objSrc)
			{
				return JSON.parse(JSON.stringify(objSrc));
			};
			
			var getArrayOfSize = function(length,callback)
			{
				var index = -1;
		        var retValue = Array(length);
		        if(callback)
		        {
		        	while (++index < length) 
				    {
		        		retValue[index] = callback(index);
				    }
		        }
		        return retValue;
			};
			
			var getLetterFromCells = function(fromCell,toCell)
			{
				var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
				var retValue = "";
				var strData = '';
				var count = fromCell;
				var index = null;
				do 
				{
					index = (count - 1) % 26;
					strData = alphabet[index] + strData;
					count = (count - (index + 1)) / 26;
				} while (count > 0);
				retValue = strData + (toCell || '');;
				return retValue;
			};
			
			var getCellsFromLetter = function(cell) 
			{
				var retValue = {x: 0,y: 0};
				var len = cell.length;
				for (var count = 0; count < len; count++) 
				{
					var charCode = cell.charCodeAt(count);
					if (charCode >= 65) 
					{
						retValue.x = retValue.x * 26 + charCode - 64;
					} 
					else 
					{
						retValue.y = parseInt(cell.slice(count), 10);
						break;
					}
				}
				return retValue;
			};
			
			var getCanonCell = function(cell) 
			{
				if(isObject(cell))
				{
					return getLetterFromCells(cell.c || 1, cell.r || 1);
				}
				return cell;
			};
			
			initialize();
			
			self.getXML = getXML;
			self.escapeString = escapeString;
			self.addSheetProp = addSheetProp;
			self.getSheetProp = getSheetProp;
			self.getCanonColor = getCanonColor;
			self.getColorTag = getColorTag;
			self.hasInArray = hasInArray;
			self.isObject = isObject;
			self.isString = isString;
			self.isDate = isDate;
			self.isArray = isArray;
			self.isObjectEmpty = isObjectEmpty;
			self.getDateTimeValue = getDateTimeValue;
			self.cloneObject = cloneObject;
			self.getArrayOfSize = getArrayOfSize;
			self.getLetterFromCells = getLetterFromCells;
			self.getCellsFromLetter = getCellsFromLetter;
			self.getCanonCell = getCanonCell;
			self.xmlPrefix = xmlPrefix;
			self.schemas = schemas;
			self.numberPredifined = numberPredifined;
		};
