var NSXlsxExport = (function()
{
	var NSXlsxExport = function(config)
	{
		var self = this;
		var util = null;
		var xlsxUtil = null;
		var workbook = null;
		var styles = null;
		var setting = {};
		
		var initialize = function()
		{
			util = new NSUtil();
			if(!config)
			{
				config = {};
			}
			setting = {
				fileName: config["fileName"] || "download",
				sheets: config["sheets"]
			};
			if(!setting.sheets || setting.sheets.length == 0)
			{
				util.throwNS("sheets is not defined in config");
			}
			xlsxUtil = new XlsxUtil();
			styles = new XlsxStyle(xlsxUtil);
			workbook = new XlsxWorkbook(xlsxUtil,styles,setting.sheets);
		};
		
		var process = function()
		{
			var zip = new JSZip();
			var xl = zip.folder('xl');
			save(zip,xl);
			return zip.generateAsync({
			    type: 'blob',
			    mimeType:
			      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
			  }).then(function(blob){
				saveAs(blob, setting.fileName + '.xlsx');
			});
			
		};
		
		var save = function(zip,xl)
		{
			var strWorkbook = workbook.process();
			saveSheets(zip,xl);
			xl.file('styles.xml', getStyles());
			zip.file('[Content_Types].xml', getContentTypesXml());
			zip.file('_rels/.rels', getRels());
			xl.file('workbook.xml', strWorkbook);
			xl.file('_rels/workbook.xml.rels', getWorkbookXMLRels());
		};
		
		var saveSheets = function(zip,xl)
		{
			for(var count = 0;count < setting.sheets.length;count++)
			{
				var sheet = workbook.getSheet(count);
				xl.file(sheet.getPath(),sheet.getSheetData());
				xlsxUtil.setSheetProp("relationship",sheet.getRelationship());
				xlsxUtil.setSheetProp("override",sheet.getOverride());
			}
		};
		
		var getWorkbookXMLRels = function()
		{
			var relationShip = {style:{type:xlsxUtil.schemas.stylesheet,target:'styles.xml'},
								sharedStrings:{type:xlsxUtil.schemas.sharedStrings,target:'sharedStrings.xml'}
							   };
			var arrChild = [];
			var index = setting.sheets.length;
			for(var key in relationShip)
			{
				var item = relationShip[key];
				arrChild.push(xlsxUtil.getXML({
						name: 'Relationship',
						attributes: {'Id':'rId' + (++index),'Type': item.type,'Target': item.target}
				}));
			}
			arrChild.push(xlsxUtil.getSheetProp("relationship"));
			
			return xlsxUtil.getXML({
				name: 'Relationships',
				ns: 'relationshipPackage',
				children: arrChild
			});
		};
		
		var getStyles = function()
		{
			/*var style = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?> '+
						   '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><numFmts count="1"><numFmt numFmtId="164" formatCode="&quot;$&quot;#,##0.00"/></numFmts><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="2"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/><xf numFmtId="164" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext></extLst></styleSheet>';
			return style;*/
			return styles.getTag();
		};
		
		var getRels = function()
		{
			var rels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n ' +
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n ' +
			'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>\n ' +
			'</Relationships>';
			
			return rels;
		};
		
		var getContentTypesXml = function()
		{
			var override = {workbook:{partName:'/xl/workbook.xml',contentType:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'},
								styles:{partName:'/xl/styles.xml',contentType:'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'}
				   			   };
			var arrChild = [];
			arrChild.push('<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>');
			arrChild.push('<Default Extension="xml" ContentType="application/xml"/>');
			for(var key in override)
			{
				var item = override[key];
				arrChild.push(xlsxUtil.getXML({
						name: 'Override',
						attributes: {'PartName': item.partName,'ContentType': item.contentType}
				}));
			}
			arrChild.push(xlsxUtil.getSheetProp("override"));
			
			return xlsxUtil.getXML({
				name: 'Types',
				ns: 'contentTypes',
				children: arrChild
			});
		};
		
		var XlsxStyle = function(util)
		{
			var self = this;
			var objTypes = {numberFormats:{def: StyleNumberFormat},
							fonts:{def: StyleFonts},
							fills:{def: StyleFills},
							borders:{def: StyleBorder},
							cells:{def: StyleCells}};
			var defaultTableStyle = '';
			var mergeCache = {};
			
			var initialize = function()
			{
				for(var key in objTypes)
				{
					objTypes[key]["ins"] = new objTypes[key]["def"](util,self);
				}
			};
			
			var addFormat = function(style,name) 
			{
				return objTypes["cells"]["ins"].add(style,name);
			};
			
			var getStyle = function(name) 
			{
				return objTypes["cells"]["ins"].getStyle(name);
			};
			
			var getStyleID = function(name) 
			{
				return objTypes["cells"]["ins"].getStyleID(name);
			};
			
			var addFillOutFormat = function(objStyle)
			{
				if (getStyle(objStyle).fillOut) 
				{
					return objStyle;
				}
				var style = objTypes["cells"]["ins"].cutVisible(objTypes["cells"]["ins"].fullGet(objStyle));
				if(!util.isObjectEmpty(style))
				{
					return addFormat(style);
				}
				return null;
			};
			
			var merge = function(format)
			{
				var formats = [];
				for(var count = 0;count < arguments.length;count++)
				{
					if(arguments[count])
					{
						formats.push(arguments[count]);
					}
				}
				if (formats.length === 0) 
				{
					return null;
				} 
				else if (formats.length === 1) 
				{
					return addFormat(formats[0]);
				}
				else 
				{
					//https://www.w3schools.com/jsref/jsref_reduce.asp
					var id = formats.reduce(function (total, currentValue,currentIndex, arr) 
							{
								return total + JSON.stringify(currentValue);
							}, '');
					var merged = mergeCache[id];
					if (!merged) 
					{
						var cells = objTypes["cells"]["ins"];
						var newFormat = {};
						for(var index in formats)
						{
							var format = formats[index];
							newFormat = cells.merge(newFormat,cells.fullGet(format));
						}
						merged = cells.add(newFormat,null,{ merge: true});
						mergeCache[id] = merged;
					}
					return merged;
				}
				return null;
			};
			
			var addFontFormat = function(format, name) 
			{
				return objTypes["fonts"]["ins"].add(format, name);
			};
			
			var addBorderFormat = function(format, name) 
			{
				return objTypes["borders"]["ins"].add(format, name);
			};
			
			var addPatternFormat = function(format, name) 
			{
				return objTypes["fills"]["ins"].add(format, name, {fillType:'pattern'});
			};
			
			var addGradientFormat = function(format, name) 
			{
				return objTypes["fills"]["ins"].add(format, name, {fillType:'gradient'});
			};
			
			var addNumberFormat = function(format, name) 
			{
				return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var addTableFormat = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var addTableElementFormat = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var setDefaultTableStyle = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var getTag = function(objStyle)
			{
				var arrChildren = [];
				for(var key in objTypes)
				{
					//console.log(key + " :: " + objTypes[key]["ins"].getFinalTag());
					arrChildren.push(objTypes[key]["ins"].getFinalTag());
				}
				return util.getXML({
					name: 'styleSheet',
					ns: 'spreadsheetml',
					children: arrChildren
				});
			};
			
			initialize();
			
			self.addFormat = addFormat;
			self.getStyle = getStyle;
			self.getStyleID = getStyleID;
			self.addFillOutFormat = addFillOutFormat;
			self.merge = merge;
			self.addFontFormat = addFontFormat;
			self.addBorderFormat = addBorderFormat;
			self.addPatternFormat = addPatternFormat;
			self.addGradientFormat = addGradientFormat;
			self.addNumberFormat = addNumberFormat;
			self.addTableFormat = addTableFormat;
			self.addTableElementFormat = addTableElementFormat;
			self.setDefaultTableStyle = setDefaultTableStyle;
			self.getTag = getTag;
			
			self.objTypes = objTypes;
			
		};
		
		var StyleCells = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "format";
			style.saveName = "cellXfs";
			var alignment = new XlsxAlignment(util);
			var protection = new XlsxProtection(util);
			
			var ALLOWED_PARTS = ['format', 'fill', 'border', 'font'];
			var XLS_NAMES = ['numFmtId', 'fillId', 'borderId', 'fontId'];
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				for(var key in util.numberPredifined)
				{
					style.predefined[key] = {format: key};
				}
				style.idIndex = style.formats.length;
				style.saveEmpty = false;
			};
			
			style.getStyleObj = function(objStyle,prop)
			{
				var retValue = {};
				
				if (objStyle.format) 
				{
					retValue.format = xlsxStyle.objTypes["numberFormats"]["ins"].add(objStyle.format);
				}
				if (objStyle.font) 
				{
					retValue.font = xlsxStyle.objTypes["fonts"]["ins"].add(objStyle.font);
				}
				if (objStyle.pattern) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.pattern, null, { fillType: 'pattern' });
				}
				else if (objStyle.gradient) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.gradient, null, { fillType: 'gradient' });
				} 
				else if (prop && prop.merge && objStyle.fill) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.fill, null, prop);
				}
				if (objStyle.border) 
				{
					retValue.border = xlsxStyle.objTypes["borders"]["ins"].add(objStyle.border);
				}
				var alignmentValue = prop && prop.merge ? alignment.getStyleObj(objStyle.alignment) : alignment.getStyleObj(objStyle);
				if (alignmentValue) 
				{
					retValue.alignment = alignmentValue;
				}
				var protectionValue = prop && prop.merge ? protection.getStyleObj(objStyle.protection) : protection.getStyleObj(objStyle);
				if (protectionValue) 
				{
					retValue.protection = protectionValue;
				}
				if (objStyle.fillOut) 
				{
					retValue.fillOut = objStyle.fillOut;
				}
				return retValue;
			};
			
			style.fullGet = function(objStyle)
			{
				if (style.getStyleID(objStyle)) 
				{
					objStyle = style.getStyle(objStyle);
				} 
				else 
				{
					objStyle = style.getStyleObj(objStyle);
				}
				var retValue = {};
				if (objStyle.format) 
				{
					retValue.format = xlsxStyle.objTypes["numberFormats"]["ins"].getStyle(objStyle.format);
				}
				if (objStyle.font) 
				{
					retValue.font = xlsxStyle.objTypes["fonts"]["ins"].getStyle(objStyle.font);
				}
				if (objStyle.fill) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].getStyle(objStyle.fill);
				}
				if (objStyle.border) 
				{
					retValue.border = xlsxStyle.objTypes["borders"]["ins"].getStyle(objStyle.border);
				}
				if (objStyle.alignment) 
				{
					retValue.alignment = objStyle.alignment;
				}
				if (objStyle.protection) 
				{
					retValue.protection = objStyle.protection;
				}
				return retValue;
			};
			
			style.cutVisible = function(objStyle) 
			{
				var retValue = {};
				if (objStyle.format) 
				{
					retValue.format = objStyle.format;
				}
				if (objStyle.font) 
				{
					retValue.font = objStyle.font;
				}
				if (objStyle.alignment) 
				{
					retValue.alignment = objStyle.alignment;
				}
				if (objStyle.protection) 
				{
					retValue.protection = objStyle.protection;
				}
				return retValue;
			};
			
			style.merge = function(formatTo,formatFrom) 
			{
				if (formatTo.format || formatFrom.format) 
				{
					formatTo.format = xlsxStyle.objTypes["numberFormats"]["ins"].merge(formatTo.format, formatFrom.format);
				}
				if (formatTo.font || formatFrom.font) 
				{
					formatTo.font = xlsxStyle.objTypes["fonts"]["ins"].merge(formatTo.font, formatFrom.font);
				}
				if (formatTo.fill || formatFrom.fill) 
				{
					formatTo.fill = xlsxStyle.objTypes["fills"]["ins"].merge(formatTo.fill, formatFrom.fill);
				}
				if (formatTo.border || formatFrom.border) 
				{
					formatTo.border = xlsxStyle.objTypes["borders"]["ins"].merge(formatTo.border, formatFrom.border);
				}
				if (formatTo.alignment || formatFrom.alignment) 
				{
					formatTo.alignment = alignment.merge(formatTo.alignment, formatFrom.alignment);
				}
				if (formatTo.protection || formatFrom.protection) 
				{
					formatTo.protection = protection.merge(formatTo.protection, formatFrom.protection);
				}
				return formatTo;
			};
			
			style.getTag = function(objStyle)
			{
				var attributes = {};
				var children = [];
				if (objStyle.alignment) 
				{
					children.push(alignment.getTag(objStyle.alignment));
					attributes['applyAlignment'] = true;
				}
				if (objStyle.protection) 
				{
					children.push(protection.getTag(objStyle.protection));
					attributes['applyProtection'] = true;
				}
				for(var key in objStyle)
				{
					if(ALLOWED_PARTS.indexOf(key) > -1)
					{
						var value = objStyle[key];
						var xlsName = XLS_NAMES[ALLOWED_PARTS.indexOf(key)];
						if (key === 'format') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["numberFormats"]["ins"].getStyleID(value);
							attributes['applyNumberFormat'] = true;
						} 
						else if (key === 'fill') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["fills"]["ins"].getStyleID(value);
							attributes['applyFill'] = true;
						} 
						else if (key === 'border') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["borders"]["ins"].getStyleID(value);
							attributes['applyBorder'] = true;
						} 
						else if (key === 'font') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["fonts"]["ins"].getStyleID(value);
							attributes['applyFont'] = true;
						}
					}
				}

				return util.getXML({
					name: 'xf',
					attributes: attributes,
					children: children
				});
			};
			
			initialize();
			
			return style;
		};
		
		var StyleBorder = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "border";
			style.saveName = "borders";
			var mainBorders = ['left', 'right', 'top', 'bottom'];
			var borders = ['left', 'right', 'top', 'bottom', 'diagonal'];
			var borderStyle = {
					dashDot: 'dashDot',
					dashDotDot: 'dashDotDot',
					dashed: 'dashed',
					dotted: 'dotted',
					double: 'double',
					hair: 'hair',
					medium: 'medium',
					mediumDashDot: 'mediumDashDot',
					mediumDashDotDot: 'mediumDashDotDot',
					mediumDashed: 'mediumDashed',
					none: 'none',
					slantDashDot: 'slantDashDot',
					thick: 'thick',
					thin: 'thin'
			};
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle)
			{
				var retValue = {};
				if(!objStyle)
				{
					objStyle = {};
				}
				if(objStyle["style"] || objStyle["color"])
				{
					if (!objStyle["style"] || borderStyle[objStyle["style"]]) 
					{
						for(var index in mainBorders)
						{
							retValue[mainBorders[index]] = {style: objStyle.style,color: objStyle.color};
						}
					}
				}
				else
				{
					for(var index in borders)
					{
						var name = borders[index];
						var border = objStyle[name];
						if (border && (!objStyle.style || borderStyle[border.style])) 
						{
							retValue[name] = {style: border.style,color: border.color };
						} 
						else 
						{
							retValue[name] = {};
						}
					}
				}
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var tagChildren = [];
				for(var index in borders)
				{
					var childTag = borders[index];
					var border = objStyle[childTag];
					var attributes = null;
					var children = null;

					if (border) 
					{
						if (border.style) 
						{
							attributes = {'style': border.style};
						}
						if (border.color) 
						{
							children = [util.getColorTag(border.color)];
						}
					}
					tagChildren.push(util.getXML({
						name: childTag,
						attributes: attributes,
						children: children
					}));
				}
				return util.getXML({
					name: 'border',
					children: tagChildren
				});
			};
			
			style.merge = function(formatTo,formatFrom)
			{
				formatTo = (formatTo != undefined) ? formatTo : style.getStyleObj({});
				if (formatFrom) 
				{
					for(var index in borders)
					{
						var childTag = borders[index];
						var borderFrom = formatFrom[childTag];
						if (borderFrom && borderFrom.style) 
						{
							formatTo[childTag].style = borderFrom.style;
						}
						if (borderFrom && borderFrom.color) 
						{
							formatTo[childTag].color = borderFrom.color;
						}
					}
				}
				return formatTo;
			};
			
			initialize();
			
			style.borderStyle = borderStyle;
			
			return style;
		};
		
		var StyleFills = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "fill";
			style.saveName = "fills";
			
			var PATTERN_TYPES = ['none', 'solid', 'darkGray', 'mediumGray', 'lightGray', 'gray125', 'gray0625', 'darkHorizontal', 'darkVertical', 'darkDown', 'darkUp', 'darkGrid', 'darkTrellis', 'lightHorizontal', 'lightVertical', 'lightDown', 'lightUp', 'lightGrid', 'lightTrellis'];
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({ type: 'none' }, { fillType: 'pattern' }) }, { format: style.getStyleObj({ type: 'gray125' }, { fillType: 'pattern' }) });
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle,prop)
			{
				var retValue = {};
				retValue["fillType"] = prop.merge ? objStyle.fillType : prop.fillType;
				if(retValue["fillType"] === "pattern")
				{
					var fgColor = (prop.merge ? objStyle.fgColor : objStyle.color) || 'FFFFFFFF';
					var bgColor = (prop.merge ? objStyle.bgColor : objStyle.backColor) || 'FFFFFFFF';
					var patternType = prop.merge ? objStyle.patternType : objStyle.type;
					
					retValue["patternType"] = util.hasInArray(PATTERN_TYPES, patternType) ? patternType : 'solid';
					if (prop.isTable && retValue.patternType === 'solid') 
					{
						retValue["fgColor"] = bgColor;
						retValue["bgColor"] = fgColor;
					} 
					else 
					{
						retValue["fgColor"] = fgColor;
						retValue["bgColor"] = bgColor;
					}
				}
				else 
				{
					if (objStyle['left'] !== undefined)
					{
						retValue.left = objStyle.left || 0;
						retValue.right = objStyle.right || 0;
						retValue.top = objStyle.top || 0;
						retValue.bottom = objStyle.bottom || 0;
					} 
					else 
					{
						retValue.degree = objStyle.degree || 0;
					}
					retValue.start = objStyle.start || 'FFFFFFFF';
					retValue.end = objStyle.end || 'FFFFFFFF';
				}
				
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var children = (objStyle.fillType === 'pattern') ? [getPatternTag(objStyle)] : [getGradientTag(objStyle)];

				return util.getXML({
					name: 'fill',
					children: children
				});
			};
			
			var getPatternTag = function(objStyle) 
			{
				var attributes = {'patternType': objStyle.patternType};
				var children = [util.getXML({
					name: 'fgColor',
					attributes: {'rgb': util.getCanonColor(objStyle.fgColor)}
				}), util.getXML({
					name: 'bgColor',
					attributes: {'rgb': util.getCanonColor(objStyle.bgColor)}
				})];

				return util.getXML({
					name: 'patternFill',
					attributes: attributes,
					children: children
				});
			};
			
			var getGradientTag = function(objStyle) 
			{
				var attributes = {};

				if (objStyle.degree) 
				{
					attributes['degree'] = objStyle.degree;
				} 
				else if (objStyle.left) 
				{
					attributes['type'] = 'path';
					attributes['left'] = objStyle.left;
					attributes['right'] = objStyle.right;
					attributes['top'] = objStyle.top;
					attributes['bottom'] = objStyle.bottom;
				}
				var children = [util.getXML({
					name: 'stop',
					attributes: {'position': 0},
					children: [util.getColorTag(objStyle.start)]
				}), util.getXML({
					name: 'stop',
					attributes: {'position': 1},
					children: [util.getColorTag(objStyle.end)]
				})];

				return util.getXML({
					name: 'gradientFill',
					attributes: attributes,
					children: children
				});
			};

			
			initialize();
			
			return style;
		};
		
		var StyleFonts = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "font";
			style.saveName = "fonts";
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle)
			{
				var retValue = {};

				if (objStyle['bold']) 
				{
					retValue.bold = !!objStyle.bold;
				}
				if (objStyle['italic']) 
				{
					retValue.italic = !!objStyle.italic;
				}
				if (objStyle.superscript) 
				{
					retValue.vertAlign = 'superscript';
				}
				if (objStyle.subscript) 
				{
					retValue.vertAlign = 'subscript';
				}
				if (objStyle.underline) 
				{
					var arrUnderline = ['double', 'singleAccounting', 'doubleAccounting'];
					if (arrUnderline.indexOf(objStyle.underline) > -1) 
					{
						retValue.underline = objStyle.underline;
					} 
					else 
					{
						retValue.underline = true;
					}
				}
				if (objStyle['strike']) 
				{
					retValue.strike = !!objStyle.strike;
				}
				if (objStyle.outline) 
				{
					retValue.outline = true;
				}
				if (objStyle.shadow) 
				{
					retValue.shadow = true;
				}
				if (objStyle.size) 
				{
					retValue.size = objStyle.size;
				}
				if (objStyle.color) 
				{
					retValue.color = objStyle.color;
				}
				if (objStyle.fontName) 
				{
					retValue.fontName = objStyle.fontName;
				}
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var children = [];

				if (objStyle.size) 
				{
					children.push(util.getXML({
						name: 'sz',
						attributes: {'val': objStyle.size}
					}));
				}
				if (objStyle.fontName) 
				{
					children.push(util.getXML({
						name: 'name',
						attributes: {'val': objStyle.fontName}
					}));
				}
				if (objStyle['bold']) 
				{
					if (objStyle.bold) 
					{
						children.push(util.getXML({ name: 'b' }));
					} 
					else 
					{
						children.push(util.getXML({ name: 'b', attributes: {'val': 0} }));
					}
				}
				if (objStyle['italic']) 
				{
					if (objStyle.italic) 
					{
						children.push(util.getXML({ name: 'i' }));
					} else 
					{
						children.push(util.getXML({ name: 'i', attributes: {'val': 0}}));
					}
				}
				if (objStyle.vertAlign) 
				{
					children.push(util.getXML({
						name: 'vertAlign',
						attributes: {'val': objStyle.vertAlign}
					}));
				}
				if (objStyle.underline) 
				{
					var attrs = null;
					if (objStyle.underline !== true) 
					{
						attrs = {'val': objStyle.underline};
					}
					children.push(util.getXML({
						name: 'u',
						attributes: attrs
					}));
				}
				if (objStyle['strike']) 
				{
					if (objStyle.strike) 
					{
						children.push(util.getXML({ name: 'strike' }));
					} 
					else 
					{
						children.push(util.getXML({ name: 'strike', attributes: {'val': 0} }));
					}
				}
				if (objStyle.shadow) 
				{
					children.push(util.getXML({ name: 'shadow' }));
				}
				if (objStyle.outline) 
				{
					children.push(util.getXML({ name: 'outline' }));
				}
				if (objStyle.color) 
				{
					children.push(util.getColorTag(objStyle.color));
				}

				return util.getXML({
					name: 'font',
					children: children
				});
			};
			
			style.merge = function(formatTo,formatFrom)
			{
				var retValue = {};
				for(var key in formatTo)
				{
					retValue[key] = formatTo[key];
				}
				for(var key in formatFrom)
				{
					retValue[key] = formatFrom[key];
				}
				retValue.color = formatFrom && formatFrom.color || formatTo && formatTo.color;
				return retValue;
			};
			
			initialize();
			
			return style;
		};
		
		var StyleNumberFormat = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "numberFormat";
			style.saveName = "numFmts";
			
			var initialize = function()
			{
				for(var key in util.numberPredifined)
				{
					style.formatsByNames[key] = {format: key, formatId: util.numberPredifined[key].formatId};
				}
				style.idIndex = 164;
			};
			
			style.getStyleObj = function(objStyle)
			{
				return objStyle;
			};
			
			style.getTag = function(objStyle,styleFormat)
			{
				var attributes = {'numFmtId': styleFormat.formatId,'formatCode': objStyle};

				return util.getXML({
					name: 'numFmt',
					attributes: attributes
				});
			};
			
			initialize();
			
			return style;
		};
		
		var XlsxAlignment = function(util)
		{
			var self = this;
			var HORIZONTAL = ['left', 'center', 'right', 'fill', 'justify', 'centerContinuous', 'distributed'];
			var VERTICAL = ['top', 'center', 'bottom', 'justify', 'distributed'];

			var getStyleObj = function(objStyle) 
			{
				if(objStyle)
				{
					var retValue = {};
					if (objStyle['horizontal'] && HORIZONTAL.indexOf(objStyle.horizontal) > -1) 
					{
						retValue.horizontal = objStyle.horizontal;
					}
					if (objStyle['vertical'] && VERTICAL.indexOf(objStyle.vertical) > -1) 
					{
						retValue.vertical = objStyle.vertical;
					}
					if (objStyle['indent']) 
					{
						retValue.indent = objStyle.indent;
					}
					if (objStyle['justifyLastLine']) 
					{
						retValue.justifyLastLine = objStyle.justifyLastLine ? 1 : 0;
					}
					if (objStyle['readingOrder'] && _.includes([0, 1, 2], objStyle.readingOrder)) 
					{
						retValue.readingOrder = objStyle.readingOrder;
					}
					if (objStyle['relativeIndent']) 
					{
						retValue.relativeIndent = objStyle.relativeIndent;
					}
					if (objStyle['shrinkToFit']) 
					{
						retValue.shrinkToFit = objStyle.shrinkToFit ? 1 : 0;
					}
					if (objStyle['textRotation']) 
					{
						retValue.textRotation = objStyle.textRotation;
					}
					if (objStyle['wrapText']) 
					{
						retValue.wrapText = objStyle.wrapText ? 1 : 0;
					}
					if(!util.isObjectEmpty(retValue))
					{
						return retValue;
					}
				}
				
				return null;
			};
			
			var merge = function(objTo,objFrom)
			{
				var retValue = {};
			    for (var key in objFrom) 
			    { 
			    	retValue[key] = objFrom[key]; 
			    }
			    for (var key in objTo) 
			    { 
			    	retValue[key] = objTo[key]; 
			    }
			    return retValue;
			};
			
			var getTag = function(format) 
			{
				return util.getXML({
					name: 'alignment',
					attributes: format
				});
			};
			
			self.getStyleObj = getStyleObj;
			self.merge = merge;
			self.getTag = getTag;
		};
		
		var XlsxProtection = function(util)
		{
			var self = this;

			var getStyleObj = function(objStyle) 
			{
				if(objStyle)
				{
					var retValue = {};
					if (objStyle['locked']) 
					{
						retValue.locked = objStyle.locked ? 1 : 0;
					}
					if (objStyle['hidden']) 
					{
						retValue.hidden = objStyle.hidden ? 1 : 0;
					}
					if(!util.isObjectEmpty(retValue))
					{
						return retValue;
					}
				}
				return null;
			};
			
			var merge = function(objTo,objFrom)
			{
				var retValue = {};
			    for (var key in objFrom) 
			    { 
			    	retValue[key] = objFrom[key]; 
			    }
			    for (var key in objTo) 
			    { 
			    	retValue[key] = objTo[key]; 
			    }
			    return retValue;
			};
			
			var getTag = function(format) 
			{
				return util.getXML({
					name: 'protection',
					attributes: format
				});
			};
			
			self.getStyleObj = getStyleObj;
			self.merge = merge;
			self.getTag = getTag;
		};
		
		var XlsxBaseStyle = function(util,xlsxStyle)
		{
			var self = this;
			
			self.util = util;
			self.xlsxStyle = xlsxStyle;
			self.formatName = null;
			self.saveName = null;
			self.nameIndex = 1;
			self.idIndex = 0;
			self.formats = [];
			self.formatsByData = {};
			self.formatsByNames = {};
			self.predefined = {};
			self.saveEmpty = true;
			
			self.add = function(style,name,prop)
			{
				prop = prop ? prop : {};
				if (name && self.formatsByNames[name]) 
				{
					var objStyle = self.getStyleObj(style,prop);
					var strStyle = self.util.isObject(objStyle) ? JSON.stringify(objStyle) : objStyle;

					if (strStyle !== self.formatsByNames[name].stringFormat) 
					{
						self.addNewStyle(objStyle, strStyle, name);
					}
					return name;
				}
				if (!name && self.util.isString(style)) 
				{
					if (self.formatsByNames[style]) 
					{
						return style;
					} 
					else if (self.predefined[style]) 
					{
						return self.add(self.predefined[style],style);
					}
				}
				var objStyle = self.getStyleObj(style,prop);
				var stringFormat = self.util.isObject(objStyle) ? JSON.stringify(objStyle) : objStyle;
				var styleFormat = self.formatsByData[stringFormat];

				if (!styleFormat) 
				{
					styleFormat = self.addNewStyle(objStyle,stringFormat,name);
				} 
				else if (name && !self.formatsByNames[name]) 
				{
					styleFormat.name = name;
					self.formatsByNames[name] = styleFormat;
				}
				return styleFormat.name;
			};
			
			self.addNewStyle = function(objStyle,strStyle,name)
			{
				name = name || self.formatName + self.nameIndex++;
				var styleFormat = {
					name: name,
					formatId: self.idIndex++,
					format: objStyle,
					stringFormat: strStyle
				};

				self.formats.push(styleFormat);
				self.formatsByData[strStyle] = styleFormat;
				self.formatsByNames[name] = styleFormat;

				return styleFormat;
			};
			
			self.getStyleObj = function(objStyle)
			{
				return objStyle;
			};
			
			self.getStyle = function(objStyle) 
			{
				if (self.util.isString(objStyle)) 
				{
					var styleFormat = self.formatsByNames[objStyle];
					return styleFormat ? styleFormat.format : objStyle;
				}
				return objStyle;
			};
			
			self.getStyleID = function(name) 
			{
				var styleFormat = self.formatsByNames[name];
				return styleFormat ? styleFormat.formatId : self.getPredefinedID(name);
			};
			
			self.getPredefinedID = function(name) 
			{
				if (self.predefined[name]) 
				{
					return self.getStyleID(self.add(self.predefined[name],name));
				}
				return null;
			};
			
			self.getFinalTag = function()
			{
				if (self.saveEmpty || self.formats.length > 0) 
				{
					var attributes = {count:self.formats.length};
					var children = [];
					for(var index in self.formats)
					{
						var format = self.formats[index];
						children.push(self.getTag(format.format, format));
					}

					return util.getXML({
						name: self.saveName,
						attributes: attributes,
						children: children
					});
				}
				return '';
			};
			
			self.getTag = function(objStyle,prop) 
			{
				return '';
			};
			
			self.merge = function(formatTo,formatFrom)
			{
				return formatFrom || formatTo;
			};
		};
		
		var XlsxWorkbook = function(util,style,arrSheets)
		{
			var self = this;
			var arrSheet = [];
			
			var process = function() 
			{
				arrSheet = [];
				var sheetValue = "";
				if(arrSheets && arrSheets.length > 0)
				{
					for(var count = 0;count < arrSheets.length;count++)
					{
						var sheetID = count + 1;
						var sheet = new XlsxSheet(util,style,arrSheets[count],sheetID);
						sheetValue += sheet.process();
						arrSheet.push(sheet);
					}
				}
				sheetValue = '<sheets>' + sheetValue + '</sheets>';
				return util.getXML({
					name: 'workbook',
					ns: 'spreadsheetml',
					attributes: {'xmlns:r': util.schemas.r,'xmlns:mx': util.schemas.mx,'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: ['<workbookPr/>','<bookViews><workbookView activeTab="0"/></bookViews>', sheetValue, '<definedNames/>', '<calcPr/>']
				});
			};
			
			var getSheet = function(index)
			{
				if(arrSheet && arrSheet.length > index)
				{
					return arrSheet[index];
				}
				return null;
			};
			
			self.process = process;
			self.getSheet = getSheet;
		};
		
		var XlsxSheet = function(util,styles,objSheet,sheetIndex)
		{
			var self = this;
			var arrRow = [];
			var sheetData = null;
			var path = null;
			var relationsPath = null;
			var relationship = null;
			var override = null;
			var maxX = 0;
			var maxY = null;
			var isHeaderRequired = false;
			var arrProcessColumns = [];
			var objProcessRows = {};
			var arrProcessData = [];
			
			var initialize = function()
			{
				getObjColumns();
				getObjRows();
				getData();
			};
			
			var getObjColumns = function()
			{
				var arrCol = objSheet.columns;
				for(var index in arrCol)
				{
					var column = util.cloneObject(arrCol[index]);
					if(column.headerText)
					{
						isHeaderRequired = true;
					}
					if (column.style) 
					{
						column.style = styles.addFormat(column.style);
						var style = styles.addFillOutFormat(column.style);
						item.styleID = styles.getStyleID(style);
					}
					arrProcessColumns.push(column);
				}
			};
			
			var getObjRows = function()
			{
				var objRows = objSheet.rowProperties;
				if(isHeaderRequired)
				{
					var item = {};
					if(objSheet.headerStyle)
					{
						item.style = styles.addFormat(objSheet.headerStyle);
						var rowStyle = styles.addFillOutFormat(item.style);
						item.styleID = styles.getStyleID(rowStyle);
						item.skipColumnsStyle = true;
					}
					else
					{
						item.skipColumnsStyle = false;
					}
					objProcessRows[0] = item;
				}
				for(var key in objRows)
				{
					var row = util.cloneObject(objRows[key]);
					if (row.style) 
					{
						row.style = styles.addFormat(row.style);
						//var rowStyle = styles.addFillOutFormat(row.style);
						//row.styleID = styles.getStyleID(rowStyle);
					}
					row.skipColumnsStyle = row.skipColumnsStyle || false;
					var index = isHeaderRequired ? (parseInt(key) + 1) : key;
					objProcessRows[index] = row;
				}
			};
			
			var getData = function()
			{
				var dataSource = objSheet.dataSource;
				if(isHeaderRequired)
				{
					var item = {};
					for(var index in arrProcessColumns)
					{
						var column = arrProcessColumns[index];
						item[column.dataField] = column.headerText || "";
					}
					arrProcessData.push(item);
				}
				for(var index in dataSource)
				{
					var rowData = dataSource[index];
					var objRow = objProcessRows[index] || {};
					var row = getRowData(rowData,objRow);
					arrProcessData.push(row);
					//maxX = Math.max(maxX, row.length);
				}
				
				maxY = arrProcessData.length;
			};
			
			var getRowData = function(rowData,objRow)
			{
				var retValue = [];
				if(rowData)
				{
					var rowStyle = null;
					var skipColumnsStyle = false;
					var inserts = [];
					/*if (util.isArray(rowData)) 
					{
						objRow = mergeDataRowToRow(rowData,objRow);
						if (dataRow.inserts) 
						{
							inserts = dataRow.inserts;
							dataRow = _.clone(dataRow.data);
						} else {
							dataRow = dataRow.data;
						}
					}*/
					if(objRow)
					{
						rowStyle = objRow.style || null;
						skipColumnsStyle = objRow.skipColumnsStyle;
					}
					
				}
				
				return rowData;
			};
			
			var mergeDataRowToRow = function(rowData,objRow)
			{
				objRow.height = rowData.height || objRow.height;
				objRow.outlineLevel = rowData.outlineLevel || objRow.outlineLevel;
				objRow.type = rowData.type || objRow.type;
				objRow.style = rowData.style ? styles.addFormat(rowData.style) : objRow.style;
				objRow.skipColumnsStyle = rowData.skipColumnsStyle || objRow.skipColumnsStyle;

				return objRow;
			};
			
			var process = function() 
			{
				sheetData = processSheetData();
				setProp();
				return processSheet();
			};
			
			var processSheetData = function() 
			{
				arrRow = [];
				var rowValue = "";
				var colValue = "";
				if(objSheet)
				{
					colValue = processColumns(arrProcessColumns);
					if(arrProcessColumns && arrProcessColumns.length > 0 && arrProcessData && arrProcessData.length > 0)
					{
						for(var count = 0;count < arrProcessData.length;count++)
						{
							var rowIndex = count + 1;
							var rowProperties = objProcessRows[rowIndex] || {};
							var row = new XlsxRow(util,styles,arrProcessData[count],arrProcessColumns,rowIndex,rowProperties);
							rowValue += row.process();
							arrRow.push(row);
						}
					}
				}
				rowValue = '<sheetData>' + rowValue + '</sheetData>';
				
				return util.getXML({
					name: 'worksheet',
					ns: 'spreadsheetml',
					attributes: {'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:mx': util.schemas.mx,'xmlns:r': util.schemas.r,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: [colValue,rowValue]
				});
			};
			
			var processSheet = function() 
			{
				var templateSheet = '<sheet state="visible" name="###sheetName###" sheetId="###sheetIndex###" r:id="rId###sheetIndex###"/>';
				var sheet = templateSheet.replaceAll("###sheetName###",objSheet.name || ("Sheet" + sheetIndex));
				sheet = sheet.replaceAll("###sheetIndex###",sheetIndex);
				return sheet;
			};
			
			var processColumns = function(arrCol)
			{
				if(arrCol && arrCol.length > 0)
				{
					var arrChildren = [];
					for(var count = 0;count < arrCol.length;count++)
					{
						var item = arrCol[count];
						var arrAttr = {'min': item.min || count + 1, 'max': item.max || count + 1};
						if (item.hidden) 
						{
							arrAttr['hidden'] = 1;
						}
						if (item.autoFit) 
						{
							arrAttr['bestFit'] = 1;
						}
						if (item.width) 
						{
							arrAttr['customWidth'] = 1;
							arrAttr['width'] = item.width;
						} 
						else 
						{
							arrAttr['width'] = 9.140625;
						}
						if (item.styleID) 
						{
							arrAttr['style'] = item.styleID;
						}
						arrChildren.push(util.getXML({
							name: 'col',
							attributes: arrAttr
						}));
					}
					return util.getXML({
						name: 'cols',
						children: arrChildren
					});
				}
				return '';
			};
			
			var getRow = function(index)
			{
				if(arrRow && arrRow.length > index)
				{
					return arrRow[index];
				}
				return null;
			};
			
			var setProp = function()
			{
				path = 'worksheets/sheet' + sheetIndex + '.xml';
				relationsPath = 'worksheets/_rels/sheet' + sheetIndex + '.xml.rels';
				relationship = util.getXML({
					name: 'Relationship',
					attributes: {'Id': 'rId' + sheetIndex,'Type': util.schemas.worksheet,'Target': path}
				});
				override = util.getXML({
					name: 'Override',
					attributes: {'PartName': '/xl/' + path,'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'}
				});
			};
			
			var getPath = function()
			{
				return path;
			};
			
			var getRelationsPath = function()
			{
				return relationsPath;
			};
			
			var getSheetData = function()
			{
				return sheetData;
			};
			
			var getRelationship = function()
			{
				return relationship;
			};
			
			var getOverride = function()
			{
				return override;
			};
			
			initialize();
			
			self.process = process;
			self.getRow = getRow;
			self.setProp = setProp;
			self.getPath = getPath;
			self.getRelationsPath = getRelationsPath;
			self.getSheetData = getSheetData;
			self.getRelationship = getRelationship;
			self.getOverride = getOverride;
		};
		
		var XlsxRow = function(util,styles,rowData,arrCol,rowIndex,objRow)
		{
			var self = this;
			var arrCell = [];
			
			var process = function() 
			{
				arrCell = [];
				var cellValue = "";
				if(arrCol && arrCol.length > 0)
				{
					for(var count = 0;count < arrCol.length;count++)
					{
						var objCol = arrCol[count];
						var objCell = getCellDetails(objCol);
						if(objCell.isObject && objCell.isSpanRequired)
						{
							//mergeCells(dataRow, colIndex, rowIndex, value);
						}
						else
						{
							var cell = new XlsxCell(util,styles,objCol,count + 1,rowData,rowIndex,objCell,objRow,objRow.skipColumnsStyle);
							cellValue += cell.process();
							arrCell.push(cell);
						}
					}
				}
				return util.getXML({
					name: 'row',
					attributes: getAttr(),
					children: [cellValue]
				});
			};
			
			var getCellDetails = function(objCol)
			{
				var value = rowData[objCol.dataField];
				var retValue = {value: value,isObject: false,style: null,parent: null,isSpanRequired: false};
				if (value && !util.isDate(value) && (typeof value === 'undefined' ? 'undefined' : typeof value === 'object'))
				{
					retValue.isObject = true;
					if (value.style) 
					{
						retValue.style = value.style;
					}
					if (value.colspan || value.rowspan) 
					{
						retValue.isSpanRequired = true;
					}
					retValue.parent = value;
					retValue.value = value.value;
				}
				
				return retValue;
			};
			
			var getAttr = function()
			{
				var attr = {'r': rowIndex};
				if (objRow.height !== undefined) 
				{
					attr["customHeight"] = 1;
					attr["ht"] = objRow.height;
				}
				if (objRow.styleID) 
				{
					attr["customFormat"] = 1;
					attr["s"] = objRow.styleID;
				}
				if (objRow.outlineLevel) 
				{
					attr["outlineLevel"] = objRow.outlineLevel;
				}
				return attr;
			};
			
			var getCell = function(index)
			{
				if(arrCell && arrCell.length > index)
				{
					return arrCell[index];
				}
				return null;
			};
			
			self.process = process;
			self.getCell = getCell;
			
		};
		
		var XlsxCell = function(util,styles,objCol,cellIndex,rowData,rowIndex,objCell,objRow,skipColumnsStyle)
		{
			var self = this;
			var dataType = null;
			
			initialize = function()
			{
				
			};
			
			var process = function() 
			{
				var value = objCell.value;
				var cellStyle = objCell.style;
				var objValue = objCell.parent;
				var cellType = getCellType(value);
				var dataTimeStyle = null;
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						dataTimeStyle = cellType;
						break;
					}
				}
				var columnStyle = !skipColumnsStyle ? objCol.style : null;
				var rowStyle = objRow.style;
				var finalCellStyleID = styles.getStyleID(styles.merge(dataTimeStyle,columnStyle,rowStyle,cellStyle));
				var objCellValue = getCellObj(cellType,value);
				var attributes = getAttr(cellIndex - 1,rowIndex,cellType,finalCellStyleID);
				var children = "";
				if (objCellValue.formula != undefined && objCellValue.formula != null) 
				{
					children = '<v>' + objCellValue.formula + '</v>';
				}
				else if (objCellValue.value != undefined && objCellValue.value != null) 
				{
					if(cellType == "string")
					{
						children = '<is><t>' + objCellValue.value + '</t></is>';
					}
					else
					{
						children = '<v>' + objCellValue.value + '</v>';
					}
				}
				return util.getXML({
					name: 'c',
					attributes: attributes,
					children: [children]
				});
			};
			
			var getAttr = function(index,rowIndex,cellType,styleID)
			{
				var attr = {'r': generatorCellNumber(index, rowIndex)};
				if (styleID) 
				{
					attr["s"] = styleID;
				}
				switch (cellType)
				{
					case "string":
						attr["t"] = "inlineStr"; 
					break;
					case "boolean":
						attr["t"] = "b"; 
					break;
				}
				return attr;
			};
			
			var getCellType = function(value)
			{
				var cellType = objCol.type;
				if(cellType)
				{
					return cellType;
				}
				else if (rowData && rowData.type) 
				{
					return row.type;
				} 
				else if (typeof value === 'number') 
				{
					return 'number';
				} 
				else if (typeof value === 'string') 
				{
					return 'string';
				}
				else if(util.isDate(value))
				{
					cellType = "date";
				}
				return cellType;
			};
			
			var getCellObj = function(cellType,cellValue) 
			{
				var retValue = {value: null,formula: null,isString: false};
				
				var formulaFunc = function(objRet,value)
				{
					objRet.formula = util.escapeString(value);
					return objRet;
				};
				
				var stringFunc = function(objRet,value)
				{
					objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				
				var mapCellType = {string: {func: stringFunc},
								   formula:{func: formulaFunc}};
				for(var key in mapCellType)
				{
					if(cellType == key)
					{
						return mapCellType[key].func(retValue,cellValue);
					}
				}
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						return util.numberPredifined[key].cellObjFunc(retValue,cellValue);
					}
				}
				retValue.value = cellValue;
				return retValue;
			};
			
			var generatorCellNumber = function(index, rowNumber)
			{
				return generateColumnLetter(index) + rowNumber;
			};
			
			var generateColumnLetter = function(colIndex) 
			{
				if (typeof colIndex !== 'number') 
				{
					return '';
				}
				var prefix = Math.floor(colIndex / 26);
				var letter = String.fromCharCode(97 + (colIndex % 26)).toUpperCase();
				if (prefix === 0) 
				{
					return letter;
				}
				return generateColumnLetter(prefix - 1) + letter;
			};
			
			initialize();
			
			self.process = process;
		};
		
		var XlsxUtil = function()
		{
			var self = this;
			var objSheetsProp = {};
			
			var xmlPrefix = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
			var schemas = {
					'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
					'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',
					'mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
					'mv': 'urn:schemas-microsoft-com:mac:vml',
					'x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
					'x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
					'xm': 'http://schemas.microsoft.com/office/excel/2006/main',
					'spreadsheetml': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
					'relationshipPackage': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'worksheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
					'stylesheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
					'sharedStrings': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
					'contentTypes': 'http://schemas.openxmlformats.org/package/2006/content-types',
					
					'officeDocument': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
					'package': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'table': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
					'spreadsheetDrawing': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
					'drawing': 'http://schemas.openxmlformats.org/drawingml/2006/main',
					'drawingRelationship': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
					'image': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
					'chart': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
					'hyperlink': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink'
			};
			var numberPredifined = null;
			
			var initialize = function()
			{
				var getDateTimeCellObj = function(objRet,value)
				{
					var date = getDateTimeValue(value);
					if(date)
					{
						objRet.value = date;
					}
					else
					{
						//objRet.value = this.common.strings.add(String(value));
						objRet.value = value;
						objRet.isString = true;
					}
					return objRet;
				};
				var getNumberCellObj = function(objRet,value)
				{
					objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				numberPredifined = {
						date: {formatId: 14,cellObjFunc:getDateTimeCellObj}, //mm-dd-yy
						time: {formatId: 21,cellObjFunc:getDateTimeCellObj}, //h:mm:ss
						integer: {formatId: 1,cellObjFunc:getNumberCellObj},
						double: {formatId: 2,cellObjFunc:getNumberCellObj}
				};
			};
			
			var getXML = function(config) 
			{
				var retValue = '<' + config.name;
				var content = '';

				if (config.ns) 
				{
					retValue = xmlPrefix + retValue + ' xmlns="' + schemas[config.ns] + '"';
				}
				if (config.attributes) 
				{
					for(var key in config.attributes)
					{
						retValue += ' ' + key + '="' + escapeString(config.attributes[key]) + '"';
					}
				}
				if (config.value !== undefined) 
				{
					content += escapeString(config.value);
				}
				if (config.children) 
				{
					content += config.children.join('');
				}
				if (content) 
				{
					retValue += '>' + content + '</' + config.name + '>';
				} 
				else 
				{
					retValue += '/>';
				}
				return retValue;
			};
			
			var escapeString = function(str)
			{
				return str;
			};
			
			var setSheetProp = function(prop,value)
			{
				objSheetsProp[prop] = value;
			};
			
			var getSheetProp = function(prop)
			{
				return objSheetsProp[prop];
			};
			
			var getCanonColor = function(color) 
			{
				return color[0] === '#' ? 'FF' + color.substr(1) : color;
			};
			
			var getColorTag = function(color) 
			{
				if (isString(color)) 
				{
					return getXML({
						name: 'color',
						attributes: {'rgb': getCanonColor(color)}
					});
				} 
				else 
				{
					var attributes = {};
					if (!color.tint) 
					{
						attributes['tint'] = color.tint;
					}
					if (!color.auto) 
					{
						attributes['auto'] = !!color.auto;
					}
					if (!color.theme) 
					{
						attributes['theme'] = color.theme;
					}
					return getXML({
						name: 'color',
						attributes: attributes
					});
				}
			};
			
			var hasInArray = function(arrSource,value)
			{
				 return (arrSource.indexOf(value) > -1);
			};
			
			var isObject = function(refObject)
			{
				if (typeof refObject === 'object' && refObject !== null) 
				{
				    return true;
				} 
				return false;
			};
			
			var isString = function(object) 
			{
			    return typeof object == "string";
			};
			
			var isDate = function(object) 
			{
				return (Object.prototype.toString.call(object) === "[object Date]"); 
			};
			
			var isObjectEmpty = function(obj)
			{
				for(var key in obj) 
				{
			        if(obj.hasOwnProperty(key))
			        {
			        	return false;
			        }
			    }
			    return true;
			};
			
			var getDateTimeValue = function(value)
			{
				var timezoneOffset = new Date().getTimezoneOffset() * 60 * 1000;
				var dateValue = isDate(value) ? value.valueOf() : value;
				var date = 25569.0 + (dateValue - timezoneOffset) / (60 * 60 * 24 * 1000);
				if (isFinite(date)) 
				{
					return date;
				}
				return null;
			};
			
			var cloneObject = function(objSrc)
			{
				return JSON.parse(JSON.stringify(objSrc));
			};
			
			initialize();
			
			self.getXML = getXML;
			self.escapeString = escapeString;
			self.setSheetProp = setSheetProp;
			self.getSheetProp = getSheetProp;
			self.getCanonColor = getCanonColor;
			self.getColorTag = getColorTag;
			self.hasInArray = hasInArray;
			self.isObject = isObject;
			self.isString = isString;
			self.isDate = isDate;
			self.isObjectEmpty = isObjectEmpty;
			self.getDateTimeValue = getDateTimeValue;
			self.cloneObject = cloneObject;
			self.schemas = schemas;
			self.numberPredifined = numberPredifined;
		};
		
		self.process = process;
		
		initialize();
	};
	
	return NSXlsxExport;
})();
nsModuleExport(this,"NSXlsxExport",NSXlsxExport);
