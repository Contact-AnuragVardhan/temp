				this.util.addStyleClass(this.__outerContainer,"nsTextBoxContainerAutoComplete");
				this.util.addStyleClass(this.__textBox,"nsTextBoxAutoComplete");
if(this.hasFocus() || (document.activeElement == this.__textBox) || (this.__getNSControl() && this.__getNSControl().hasFocus()))


if(!setting)
		{
			setting = {};
		}
		
    
    var callNonHierarchicalFilterFunction = function(source)
			{
				var arrReturn = [];
				for (var count = 0; count < source.length; count++) 
				{
					var item = source[count];
					if(self.__filterItemNonHierarchical(item,filter,setting,filterFunction))
					{
						arrReturn.push(item);
					}
				}
				return arrReturn;
			};
			dataSource = this.util.cloneObject(dataSource,isHierarchical);
			if(isHierarchical)
			{
				arrFilter = callFilterFunction(dataSource,1,null);
			}
			else
			{
				arrFilter = callNonHierarchicalFilterFunction(dataSource);
			}
      
      NSFilter.prototype.__filterItemNonHierarchical = function(item,filter,setting,filterFunction) 
	{
		var retValue = false;
		if(filterFunction)
		{
			retValue = filterFunction(item,filter,setting);
			this.__setItem(item,retValue);
			return retValue;
		}
		else if(filter instanceof Function) 
	    {
			retValue = filter(item,setting);
	        this.__setItem(item,retValue);
	        return retValue;
	    }
	    else if(filter instanceof Array) 
	    {
	        for (var count = 0; count < filter.length; ++count) 
	        {
	            if (this.__filterItemNonHierarchical(item,filter[count],setting,filterFunction))
	            {
	            	this.__setItem(item,true);
	            	return true;
	            }
	        }
	        return false;
	    }
	    else if(setting.type === "date" && filter)
	    {
	        return this.__filterDate(item,filter,setting);
	    }
	    else if(typeof(item) === "string" && filter)
	    {
	        return this.__filterString(item,filter,setting);
	    }
	    else if (item === item + 0 && filter)
	    {
	        return this.__filterNumeric(item,filter);
	    }
	    else if(typeof (filter) === "object") 
	    {
	        for(var key in filter) 
	        {
	        	var tempSetting = {};
	        	if(setting && setting[key])
	        	{
	        		tempSetting = setting[key];
	        	}
	            if(!this.__filterItemNonHierarchical(item[key],filter[key],tempSetting,filterFunction))
	            {
	            	return false;
	            }
	        }
	        this.__setItem(item,true);
	        return true;
	    }
		retValue = (filter == item);
	    this.__setItem(item,retValue);
	    return retValue;
	};
  
  txtFilter.setAttribute("autocomplete","off");
  
  
  menuWidth: setting["menuWidth"] || 33,
  
  var setting = {header:header};
							var ajax = new NSAjax();
							ajax.post(url,param,setting).then(
									function(response) 
									{
										config.uploadSuccessCallback && config.uploadSuccessCallback(response,self);
				                    	setImageOrignalParam();
									},
									function(response) 
									{ 
										config.uploadFailureCallback && config.uploadFailureCallback(response,self);
									}
							);
              
              var arrToolButtons = menuContainer.querySelectorAll("button.nsImageToolbarButton");
            	var width = (arrToolButtons.length * config.menuWidth);
            	menuContainer.style.left = left + "px";
            	menuContainer.style.top = top + "px";
            	menuContainer.style.width = width + "px";
              
              /*temporary removing close button from textBox in autocomplete mode as I am not listening to that event for now  */
 .nsTextBoxAutoComplete::-ms-clear
 {
 	width : 0;
 	height: 0;
 }
