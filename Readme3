var NSXlsxExport = (function()
{
	var NSXlsxExport = function(config)
	{
		var self = this;
		var xlsxUtil = null;
		var workbook = null;
		var styles = null;
		var setting = {};
		var sharedString = null;
		
		var initialize = function()
		{
			if(!config)
			{
				config = {};
			}
			xlsxUtil = new XlsxUtil();
			setting = {
				fileName: config["fileName"] || "download",
				sheets: config["sheets"]
			};
			if(!setting.sheets || setting.sheets.length == 0)
			{
				xlsxUtil.throwNSError("sheets is not defined in config");
			}
			styles = new XlsxStyle(xlsxUtil);
			sharedString = new XlsxSharedStrings(xlsxUtil);
			workbook = new XlsxWorkbook(xlsxUtil,styles,sharedString,setting.sheets);
		};
		
		var process = function()
		{
			var zip = new JSZip();
			var xl = zip.folder('xl');
			save(zip,xl);
			return zip.generateAsync({
			    type: 'blob',
			    mimeType:
			      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
			  }).then(function(blob){
				saveAs(blob, setting.fileName + '.xlsx');
			});
			
		};
		
		var save = function(zip,xl)
		{
			var strWorkbook = workbook.process();
			saveSheets(zip,xl);
			saveStyles(zip,xl);
			saveSharedStrings(zip,xl);
			zip.file('[Content_Types].xml', getContentTypesXml());
			zip.file('_rels/.rels', getRels());
			xl.file('workbook.xml', strWorkbook);
			xl.file('_rels/workbook.xml.rels', getWorkbookXMLRels());
		};
		
		var saveSheets = function(zip,xl)
		{
			for(var count = 0;count < setting.sheets.length;count++)
			{
				var sheet = workbook.getSheet(count);
				xl.file(sheet.getPath(),sheet.getSheetData());
				xlsxUtil.addSheetProp("relationship",sheet.getRelationship());
				xlsxUtil.addSheetProp("override",sheet.getOverride());
			}
		};
		
		var getWorkbookXMLRels = function()
		{
			var relationShip = {style:{type:xlsxUtil.schemas.stylesheet,target:'styles.xml'},
								sharedStrings:{type:xlsxUtil.schemas.sharedStrings,target:'sharedStrings.xml'}
							   };
			var arrChild = [];
			var index = setting.sheets.length;
			for(var key in relationShip)
			{
				var item = relationShip[key];
				arrChild.push(xlsxUtil.getXML({
						name: 'Relationship',
						attributes: {'Id':'rId' + (++index),'Type': item.type,'Target': item.target}
				}));
			}
			arrChild.push(xlsxUtil.getSheetProp("relationship"));
			
			return xlsxUtil.getXML({
				name: 'Relationships',
				ns: 'relationshipPackage',
				children: arrChild
			});
		};
		
		var saveStyles = function(zip,xl)
		{
			xl.file('styles.xml', styles.getTag());
		};
		
		var saveSharedStrings = function(zip,xl)
		{
			if (sharedString.hasString() > 0) 
			{
				xl.file('sharedStrings.xml', sharedString.getTag());
			}
		};
		
		var getRels = function()
		{
			var rels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n ' +
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n ' +
			'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>\n ' +
			'</Relationships>';
			
			return rels;
		};
		
		var getContentTypesXml = function()
		{
			var override = {workbook:{partName:'/xl/workbook.xml',contentType:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'},
								styles:{partName:'/xl/styles.xml',contentType:'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'}
				   			   };
			if (sharedString.hasString() > 0) 
			{
				override["sharedStrings"] = {partName:'/xl/sharedStrings.xml',contentType:'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'}
			}
			var arrChild = [];
			arrChild.push('<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>');
			arrChild.push('<Default Extension="xml" ContentType="application/xml"/>');
			for(var key in override)
			{
				var item = override[key];
				arrChild.push(xlsxUtil.getXML({
						name: 'Override',
						attributes: {'PartName': item.partName,'ContentType': item.contentType}
				}));
			}
			arrChild.push(xlsxUtil.getSheetProp("override"));
			
			return xlsxUtil.getXML({
				name: 'Types',
				ns: 'contentTypes',
				children: arrChild
			});
		};
		
		var XlsxStyle = function(util)
		{
			var self = this;
			var objTypes = {numberFormats:{def: StyleNumberFormat},
							fonts:{def: StyleFonts},
							fills:{def: StyleFills},
							borders:{def: StyleBorder},
							cells:{def: StyleCells}};
			var defaultTableStyle = '';
			var mergeCache = {};
			
			var initialize = function()
			{
				for(var key in objTypes)
				{
					objTypes[key]["ins"] = new objTypes[key]["def"](util,self);
				}
			};
			
			var addFormat = function(style,name) 
			{
				return objTypes["cells"]["ins"].add(style,name);
			};
			
			var getStyle = function(name) 
			{
				return objTypes["cells"]["ins"].getStyle(name);
			};
			
			var getStyleID = function(name) 
			{
				return objTypes["cells"]["ins"].getStyleID(name);
			};
			
			var addFillOutFormat = function(objStyle)
			{
				if (getStyle(objStyle).fillOut) 
				{
					return objStyle;
				}
				var style = objTypes["cells"]["ins"].cutVisible(objTypes["cells"]["ins"].fullGet(objStyle));
				if(!util.isObjectEmpty(style))
				{
					return addFormat(style);
				}
				return null;
			};
			
			var merge = function(format)
			{
				var formats = [];
				for(var count = 0;count < arguments.length;count++)
				{
					if(arguments[count])
					{
						formats.push(arguments[count]);
					}
				}
				if (formats.length === 0) 
				{
					return null;
				} 
				else if (formats.length === 1) 
				{
					return addFormat(formats[0]);
				}
				else 
				{
					//https://www.w3schools.com/jsref/jsref_reduce.asp
					var id = formats.reduce(function (total, currentValue,currentIndex, arr) 
							{
								return total + JSON.stringify(currentValue);
							}, '');
					var merged = mergeCache[id];
					if (!merged) 
					{
						var cells = objTypes["cells"]["ins"];
						var newFormat = {};
						for(var index in formats)
						{
							var format = formats[index];
							newFormat = cells.merge(newFormat,cells.fullGet(format));
						}
						merged = cells.add(newFormat,null,{ merge: true});
						mergeCache[id] = merged;
					}
					return merged;
				}
				return null;
			};
			
			var addFontFormat = function(format, name) 
			{
				return objTypes["fonts"]["ins"].add(format, name);
			};
			
			var addBorderFormat = function(format, name) 
			{
				return objTypes["borders"]["ins"].add(format, name);
			};
			
			var addPatternFormat = function(format, name) 
			{
				return objTypes["fills"]["ins"].add(format, name, {fillType:'pattern'});
			};
			
			var addGradientFormat = function(format, name) 
			{
				return objTypes["fills"]["ins"].add(format, name, {fillType:'gradient'});
			};
			
			var addNumberFormat = function(format, name) 
			{
				return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var addTableFormat = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var addTableElementFormat = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var setDefaultTableStyle = function(format, name) 
			{
				//return objTypes["numberFormats"]["ins"].add(format, name);
			};
			
			var getTag = function(objStyle)
			{
				var arrChildren = [];
				for(var key in objTypes)
				{
					//console.log(key + " :: " + objTypes[key]["ins"].getFinalTag());
					arrChildren.push(objTypes[key]["ins"].getFinalTag());
				}
				return util.getXML({
					name: 'styleSheet',
					ns: 'spreadsheetml',
					children: arrChildren
				});
			};
			
			initialize();
			
			self.addFormat = addFormat;
			self.getStyle = getStyle;
			self.getStyleID = getStyleID;
			self.addFillOutFormat = addFillOutFormat;
			self.merge = merge;
			self.addFontFormat = addFontFormat;
			self.addBorderFormat = addBorderFormat;
			self.addPatternFormat = addPatternFormat;
			self.addGradientFormat = addGradientFormat;
			self.addNumberFormat = addNumberFormat;
			self.addTableFormat = addTableFormat;
			self.addTableElementFormat = addTableElementFormat;
			self.setDefaultTableStyle = setDefaultTableStyle;
			self.getTag = getTag;
			
			self.objTypes = objTypes;
			
		};
		
		var StyleCells = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "format";
			style.saveName = "cellXfs";
			var alignment = new XlsxAlignment(util);
			var protection = new XlsxProtection(util);
			
			var ALLOWED_PARTS = ['format', 'fill', 'border', 'font'];
			var XLS_NAMES = ['numFmtId', 'fillId', 'borderId', 'fontId'];
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				for(var key in util.numberPredifined)
				{
					style.predefined[key] = {format: key};
				}
				style.idIndex = style.formats.length;
				style.saveEmpty = false;
			};
			
			style.getStyleObj = function(objStyle,prop)
			{
				var retValue = {};
				
				if (objStyle.format) 
				{
					retValue.format = xlsxStyle.objTypes["numberFormats"]["ins"].add(objStyle.format);
				}
				if (objStyle.font) 
				{
					retValue.font = xlsxStyle.objTypes["fonts"]["ins"].add(objStyle.font);
				}
				if (objStyle.pattern) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.pattern, null, { fillType: 'pattern' });
				}
				else if (objStyle.gradient) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.gradient, null, { fillType: 'gradient' });
				} 
				else if (prop && prop.merge && objStyle.fill) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].add(objStyle.fill, null, prop);
				}
				if (objStyle.border) 
				{
					retValue.border = xlsxStyle.objTypes["borders"]["ins"].add(objStyle.border);
				}
				var alignmentValue = prop && prop.merge ? alignment.getStyleObj(objStyle.alignment) : alignment.getStyleObj(objStyle);
				if (alignmentValue) 
				{
					retValue.alignment = alignmentValue;
				}
				var protectionValue = prop && prop.merge ? protection.getStyleObj(objStyle.protection) : protection.getStyleObj(objStyle);
				if (protectionValue) 
				{
					retValue.protection = protectionValue;
				}
				if (objStyle.fillOut) 
				{
					retValue.fillOut = objStyle.fillOut;
				}
				return retValue;
			};
			
			style.fullGet = function(objStyle)
			{
				if (style.getStyleID(objStyle)) 
				{
					objStyle = style.getStyle(objStyle);
				} 
				else 
				{
					objStyle = style.getStyleObj(objStyle);
				}
				var retValue = {};
				if (objStyle.format) 
				{
					retValue.format = xlsxStyle.objTypes["numberFormats"]["ins"].getStyle(objStyle.format);
				}
				if (objStyle.font) 
				{
					retValue.font = xlsxStyle.objTypes["fonts"]["ins"].getStyle(objStyle.font);
				}
				if (objStyle.fill) 
				{
					retValue.fill = xlsxStyle.objTypes["fills"]["ins"].getStyle(objStyle.fill);
				}
				if (objStyle.border) 
				{
					retValue.border = xlsxStyle.objTypes["borders"]["ins"].getStyle(objStyle.border);
				}
				if (objStyle.alignment) 
				{
					retValue.alignment = objStyle.alignment;
				}
				if (objStyle.protection) 
				{
					retValue.protection = objStyle.protection;
				}
				return retValue;
			};
			
			style.cutVisible = function(objStyle) 
			{
				var retValue = {};
				if (objStyle.format) 
				{
					retValue.format = objStyle.format;
				}
				if (objStyle.font) 
				{
					retValue.font = objStyle.font;
				}
				if (objStyle.alignment) 
				{
					retValue.alignment = objStyle.alignment;
				}
				if (objStyle.protection) 
				{
					retValue.protection = objStyle.protection;
				}
				return retValue;
			};
			
			style.merge = function(formatTo,formatFrom) 
			{
				if (formatTo.format || formatFrom.format) 
				{
					formatTo.format = xlsxStyle.objTypes["numberFormats"]["ins"].merge(formatTo.format, formatFrom.format);
				}
				if (formatTo.font || formatFrom.font) 
				{
					formatTo.font = xlsxStyle.objTypes["fonts"]["ins"].merge(formatTo.font, formatFrom.font);
				}
				if (formatTo.fill || formatFrom.fill) 
				{
					formatTo.fill = xlsxStyle.objTypes["fills"]["ins"].merge(formatTo.fill, formatFrom.fill);
				}
				if (formatTo.border || formatFrom.border) 
				{
					formatTo.border = xlsxStyle.objTypes["borders"]["ins"].merge(formatTo.border, formatFrom.border);
				}
				if (formatTo.alignment || formatFrom.alignment) 
				{
					formatTo.alignment = alignment.merge(formatTo.alignment, formatFrom.alignment);
				}
				if (formatTo.protection || formatFrom.protection) 
				{
					formatTo.protection = protection.merge(formatTo.protection, formatFrom.protection);
				}
				return formatTo;
			};
			
			style.getTag = function(objStyle)
			{
				var attributes = {};
				var children = [];
				if (objStyle.alignment) 
				{
					children.push(alignment.getTag(objStyle.alignment));
					attributes['applyAlignment'] = true;
				}
				if (objStyle.protection) 
				{
					children.push(protection.getTag(objStyle.protection));
					attributes['applyProtection'] = true;
				}
				for(var key in objStyle)
				{
					if(ALLOWED_PARTS.indexOf(key) > -1)
					{
						var value = objStyle[key];
						var xlsName = XLS_NAMES[ALLOWED_PARTS.indexOf(key)];
						if (key === 'format') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["numberFormats"]["ins"].getStyleID(value);
							attributes['applyNumberFormat'] = true;
						} 
						else if (key === 'fill') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["fills"]["ins"].getStyleID(value);
							attributes['applyFill'] = true;
						} 
						else if (key === 'border') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["borders"]["ins"].getStyleID(value);
							attributes['applyBorder'] = true;
						} 
						else if (key === 'font') 
						{
							attributes[xlsName] = xlsxStyle.objTypes["fonts"]["ins"].getStyleID(value);
							attributes['applyFont'] = true;
						}
					}
				}

				return util.getXML({
					name: 'xf',
					attributes: attributes,
					children: children
				});
			};
			
			initialize();
			
			return style;
		};
		
		var StyleBorder = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "border";
			style.saveName = "borders";
			var mainBorders = ['left', 'right', 'top', 'bottom'];
			var borders = ['left', 'right', 'top', 'bottom', 'diagonal'];
			var borderStyle = {
					dashDot: 'dashDot',
					dashDotDot: 'dashDotDot',
					dashed: 'dashed',
					dotted: 'dotted',
					double: 'double',
					hair: 'hair',
					medium: 'medium',
					mediumDashDot: 'mediumDashDot',
					mediumDashDotDot: 'mediumDashDotDot',
					mediumDashed: 'mediumDashed',
					none: 'none',
					slantDashDot: 'slantDashDot',
					thick: 'thick',
					thin: 'thin'
			};
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle)
			{
				var retValue = {};
				if(!objStyle)
				{
					objStyle = {};
				}
				if(objStyle["style"] || objStyle["color"])
				{
					if (!objStyle["style"] || borderStyle[objStyle["style"]]) 
					{
						for(var index in mainBorders)
						{
							retValue[mainBorders[index]] = {style: objStyle.style,color: objStyle.color};
						}
					}
				}
				else
				{
					for(var index in borders)
					{
						var name = borders[index];
						var border = objStyle[name];
						if (border && (!objStyle.style || borderStyle[border.style])) 
						{
							retValue[name] = {style: border.style,color: border.color };
						} 
						else 
						{
							retValue[name] = {};
						}
					}
				}
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var tagChildren = [];
				for(var index in borders)
				{
					var childTag = borders[index];
					var border = objStyle[childTag];
					var attributes = null;
					var children = null;

					if (border) 
					{
						if (border.style) 
						{
							attributes = {'style': border.style};
						}
						if (border.color) 
						{
							children = [util.getColorTag(border.color)];
						}
					}
					tagChildren.push(util.getXML({
						name: childTag,
						attributes: attributes,
						children: children
					}));
				}
				return util.getXML({
					name: 'border',
					children: tagChildren
				});
			};
			
			style.merge = function(formatTo,formatFrom)
			{
				formatTo = (!util.isUndefinedOrNull(formatTo)) ? formatTo : style.getStyleObj({});
				if (formatFrom) 
				{
					for(var index in borders)
					{
						var childTag = borders[index];
						var borderFrom = formatFrom[childTag];
						if (borderFrom && borderFrom.style) 
						{
							formatTo[childTag].style = borderFrom.style;
						}
						if (borderFrom && borderFrom.color) 
						{
							formatTo[childTag].color = borderFrom.color;
						}
					}
				}
				return formatTo;
			};
			
			initialize();
			
			style.borderStyle = borderStyle;
			
			return style;
		};
		
		var StyleFills = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "fill";
			style.saveName = "fills";
			
			var PATTERN_TYPES = ['none', 'solid', 'darkGray', 'mediumGray', 'lightGray', 'gray125', 'gray0625', 'darkHorizontal', 'darkVertical', 'darkDown', 'darkUp', 'darkGrid', 'darkTrellis', 'lightHorizontal', 'lightVertical', 'lightDown', 'lightUp', 'lightGrid', 'lightTrellis'];
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({ type: 'none' }, { fillType: 'pattern' }) }, { format: style.getStyleObj({ type: 'gray125' }, { fillType: 'pattern' }) });
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle,prop)
			{
				var retValue = {};
				retValue["fillType"] = prop.merge ? objStyle.fillType : prop.fillType;
				if(retValue["fillType"] === "pattern")
				{
					var fgColor = (prop.merge ? objStyle.fgColor : objStyle.color) || 'FFFFFFFF';
					var bgColor = (prop.merge ? objStyle.bgColor : objStyle.backColor) || 'FFFFFFFF';
					var patternType = prop.merge ? objStyle.patternType : objStyle.type;
					
					retValue["patternType"] = util.hasInArray(PATTERN_TYPES, patternType) ? patternType : 'solid';
					if (prop.isTable && retValue.patternType === 'solid') 
					{
						retValue["fgColor"] = bgColor;
						retValue["bgColor"] = fgColor;
					} 
					else 
					{
						retValue["fgColor"] = fgColor;
						retValue["bgColor"] = bgColor;
					}
				}
				else 
				{
					if (!util.isUndefinedOrNull(objStyle['left']))
					{
						retValue.left = objStyle.left || 0;
						retValue.right = objStyle.right || 0;
						retValue.top = objStyle.top || 0;
						retValue.bottom = objStyle.bottom || 0;
					} 
					else 
					{
						retValue.degree = objStyle.degree || 0;
					}
					retValue.start = objStyle.start || 'FFFFFFFF';
					retValue.end = objStyle.end || 'FFFFFFFF';
				}
				
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var children = (objStyle.fillType === 'pattern') ? [getPatternTag(objStyle)] : [getGradientTag(objStyle)];

				return util.getXML({
					name: 'fill',
					children: children
				});
			};
			
			var getPatternTag = function(objStyle) 
			{
				var attributes = {'patternType': objStyle.patternType};
				var children = [util.getXML({
					name: 'fgColor',
					attributes: {'rgb': util.getCanonColor(objStyle.fgColor)}
				}), util.getXML({
					name: 'bgColor',
					attributes: {'rgb': util.getCanonColor(objStyle.bgColor)}
				})];

				return util.getXML({
					name: 'patternFill',
					attributes: attributes,
					children: children
				});
			};
			
			var getGradientTag = function(objStyle) 
			{
				var attributes = {};

				if (objStyle.degree) 
				{
					attributes['degree'] = objStyle.degree;
				} 
				else if (objStyle.left) 
				{
					attributes['type'] = 'path';
					attributes['left'] = objStyle.left;
					attributes['right'] = objStyle.right;
					attributes['top'] = objStyle.top;
					attributes['bottom'] = objStyle.bottom;
				}
				var children = [util.getXML({
					name: 'stop',
					attributes: {'position': 0},
					children: [util.getColorTag(objStyle.start)]
				}), util.getXML({
					name: 'stop',
					attributes: {'position': 1},
					children: [util.getColorTag(objStyle.end)]
				})];

				return util.getXML({
					name: 'gradientFill',
					attributes: attributes,
					children: children
				});
			};

			
			initialize();
			
			return style;
		};
		
		var StyleFonts = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "font";
			style.saveName = "fonts";
			
			var initialize = function()
			{
				style.formats.push({format: style.getStyleObj({})});
				style.idIndex = style.formats.length;
			};
			
			style.getStyleObj = function(objStyle)
			{
				var retValue = {};

				if (objStyle['bold']) 
				{
					retValue.bold = !!objStyle.bold;
				}
				if (objStyle['italic']) 
				{
					retValue.italic = !!objStyle.italic;
				}
				if (objStyle.superscript) 
				{
					retValue.vertAlign = 'superscript';
				}
				if (objStyle.subscript) 
				{
					retValue.vertAlign = 'subscript';
				}
				if (objStyle.underline) 
				{
					var arrUnderline = ['double', 'singleAccounting', 'doubleAccounting'];
					if (arrUnderline.indexOf(objStyle.underline) > -1) 
					{
						retValue.underline = objStyle.underline;
					} 
					else 
					{
						retValue.underline = true;
					}
				}
				if (objStyle['strike']) 
				{
					retValue.strike = !!objStyle.strike;
				}
				if (objStyle.outline) 
				{
					retValue.outline = true;
				}
				if (objStyle.shadow) 
				{
					retValue.shadow = true;
				}
				if (objStyle.size) 
				{
					retValue.size = objStyle.size;
				}
				if (objStyle.color) 
				{
					retValue.color = objStyle.color;
				}
				if (objStyle.fontName) 
				{
					retValue.fontName = objStyle.fontName;
				}
				return retValue;
			};
			
			style.getTag = function(objStyle)
			{
				var children = [];

				if (objStyle.size) 
				{
					children.push(util.getXML({
						name: 'sz',
						attributes: {'val': objStyle.size}
					}));
				}
				if (objStyle.fontName) 
				{
					children.push(util.getXML({
						name: 'name',
						attributes: {'val': objStyle.fontName}
					}));
				}
				if (objStyle['bold']) 
				{
					if (objStyle.bold) 
					{
						children.push(util.getXML({ name: 'b' }));
					} 
					else 
					{
						children.push(util.getXML({ name: 'b', attributes: {'val': 0} }));
					}
				}
				if (objStyle['italic']) 
				{
					if (objStyle.italic) 
					{
						children.push(util.getXML({ name: 'i' }));
					} else 
					{
						children.push(util.getXML({ name: 'i', attributes: {'val': 0}}));
					}
				}
				if (objStyle.vertAlign) 
				{
					children.push(util.getXML({
						name: 'vertAlign',
						attributes: {'val': objStyle.vertAlign}
					}));
				}
				if (objStyle.underline) 
				{
					var attrs = null;
					if (objStyle.underline !== true) 
					{
						attrs = {'val': objStyle.underline};
					}
					children.push(util.getXML({
						name: 'u',
						attributes: attrs
					}));
				}
				if (objStyle['strike']) 
				{
					if (objStyle.strike) 
					{
						children.push(util.getXML({ name: 'strike' }));
					} 
					else 
					{
						children.push(util.getXML({ name: 'strike', attributes: {'val': 0} }));
					}
				}
				if (objStyle.shadow) 
				{
					children.push(util.getXML({ name: 'shadow' }));
				}
				if (objStyle.outline) 
				{
					children.push(util.getXML({ name: 'outline' }));
				}
				if (objStyle.color) 
				{
					children.push(util.getColorTag(objStyle.color));
				}

				return util.getXML({
					name: 'font',
					children: children
				});
			};
			
			style.merge = function(formatTo,formatFrom)
			{
				var retValue = {};
				for(var key in formatTo)
				{
					retValue[key] = formatTo[key];
				}
				for(var key in formatFrom)
				{
					retValue[key] = formatFrom[key];
				}
				retValue.color = formatFrom && formatFrom.color || formatTo && formatTo.color;
				return retValue;
			};
			
			initialize();
			
			return style;
		};
		
		var StyleNumberFormat = function(util,xlsxStyle)
		{
			var self =  this;
			var style = new XlsxBaseStyle(util,xlsxStyle);
			style.formatName = "numberFormat";
			style.saveName = "numFmts";
			
			var initialize = function()
			{
				for(var key in util.numberPredifined)
				{
					style.formatsByNames[key] = {format: key, formatId: util.numberPredifined[key].formatId};
				}
				style.idIndex = 164;
			};
			
			style.getStyleObj = function(objStyle)
			{
				return objStyle;
			};
			
			style.getTag = function(objStyle,styleFormat)
			{
				var attributes = {'numFmtId': styleFormat.formatId,'formatCode': objStyle};

				return util.getXML({
					name: 'numFmt',
					attributes: attributes
				});
			};
			
			initialize();
			
			return style;
		};
		
		var XlsxAlignment = function(util)
		{
			var self = this;
			var HORIZONTAL = ['left', 'center', 'right', 'fill', 'justify', 'centerContinuous', 'distributed'];
			var VERTICAL = ['top', 'center', 'bottom', 'justify', 'distributed'];

			var getStyleObj = function(objStyle) 
			{
				if(objStyle)
				{
					var retValue = {};
					if (objStyle['horizontal'] && HORIZONTAL.indexOf(objStyle.horizontal) > -1) 
					{
						retValue.horizontal = objStyle.horizontal;
					}
					if (objStyle['vertical'] && VERTICAL.indexOf(objStyle.vertical) > -1) 
					{
						retValue.vertical = objStyle.vertical;
					}
					if (objStyle['indent']) 
					{
						retValue.indent = objStyle.indent;
					}
					if (objStyle['justifyLastLine']) 
					{
						retValue.justifyLastLine = objStyle.justifyLastLine ? 1 : 0;
					}
					if (objStyle['readingOrder'] && _.includes([0, 1, 2], objStyle.readingOrder)) 
					{
						retValue.readingOrder = objStyle.readingOrder;
					}
					if (objStyle['relativeIndent']) 
					{
						retValue.relativeIndent = objStyle.relativeIndent;
					}
					if (objStyle['shrinkToFit']) 
					{
						retValue.shrinkToFit = objStyle.shrinkToFit ? 1 : 0;
					}
					if (objStyle['textRotation']) 
					{
						retValue.textRotation = objStyle.textRotation;
					}
					if (objStyle['wrapText']) 
					{
						retValue.wrapText = objStyle.wrapText ? 1 : 0;
					}
					if(!util.isObjectEmpty(retValue))
					{
						return retValue;
					}
				}
				
				return null;
			};
			
			var merge = function(objTo,objFrom)
			{
				var retValue = {};
			    for (var key in objFrom) 
			    { 
			    	retValue[key] = objFrom[key]; 
			    }
			    for (var key in objTo) 
			    { 
			    	retValue[key] = objTo[key]; 
			    }
			    return retValue;
			};
			
			var getTag = function(format) 
			{
				return util.getXML({
					name: 'alignment',
					attributes: format
				});
			};
			
			self.getStyleObj = getStyleObj;
			self.merge = merge;
			self.getTag = getTag;
		};
		
		var XlsxProtection = function(util)
		{
			var self = this;

			var getStyleObj = function(objStyle) 
			{
				if(objStyle)
				{
					var retValue = {};
					if (objStyle['locked']) 
					{
						retValue.locked = objStyle.locked ? 1 : 0;
					}
					if (objStyle['hidden']) 
					{
						retValue.hidden = objStyle.hidden ? 1 : 0;
					}
					if(!util.isObjectEmpty(retValue))
					{
						return retValue;
					}
				}
				return null;
			};
			
			var merge = function(objTo,objFrom)
			{
				var retValue = {};
			    for (var key in objFrom) 
			    { 
			    	retValue[key] = objFrom[key]; 
			    }
			    for (var key in objTo) 
			    { 
			    	retValue[key] = objTo[key]; 
			    }
			    return retValue;
			};
			
			var getTag = function(format) 
			{
				return util.getXML({
					name: 'protection',
					attributes: format
				});
			};
			
			self.getStyleObj = getStyleObj;
			self.merge = merge;
			self.getTag = getTag;
		};
		
		var XlsxBaseStyle = function(util,xlsxStyle)
		{
			var self = this;
			
			self.util = util;
			self.xlsxStyle = xlsxStyle;
			self.formatName = null;
			self.saveName = null;
			self.nameIndex = 1;
			self.idIndex = 0;
			self.formats = [];
			self.formatsByData = {};
			self.formatsByNames = {};
			self.predefined = {};
			self.saveEmpty = true;
			
			self.add = function(style,name,prop)
			{
				prop = prop ? prop : {};
				if (name && self.formatsByNames[name]) 
				{
					var objStyle = self.getStyleObj(style,prop);
					var strStyle = self.util.isObject(objStyle) ? JSON.stringify(objStyle) : objStyle;

					if (strStyle !== self.formatsByNames[name].stringFormat) 
					{
						self.addNewStyle(objStyle, strStyle, name);
					}
					return name;
				}
				if (!name && self.util.isString(style)) 
				{
					if (self.formatsByNames[style]) 
					{
						return style;
					} 
					else if (self.predefined[style]) 
					{
						return self.add(self.predefined[style],style);
					}
				}
				var objStyle = self.getStyleObj(style,prop);
				var stringFormat = self.util.isObject(objStyle) ? JSON.stringify(objStyle) : objStyle;
				var styleFormat = self.formatsByData[stringFormat];

				if (!styleFormat) 
				{
					styleFormat = self.addNewStyle(objStyle,stringFormat,name);
				} 
				else if (name && !self.formatsByNames[name]) 
				{
					styleFormat.name = name;
					self.formatsByNames[name] = styleFormat;
				}
				return styleFormat.name;
			};
			
			self.addNewStyle = function(objStyle,strStyle,name)
			{
				name = name || self.formatName + self.nameIndex++;
				var styleFormat = {
					name: name,
					formatId: self.idIndex++,
					format: objStyle,
					stringFormat: strStyle
				};

				self.formats.push(styleFormat);
				self.formatsByData[strStyle] = styleFormat;
				self.formatsByNames[name] = styleFormat;

				return styleFormat;
			};
			
			self.getStyleObj = function(objStyle)
			{
				return objStyle;
			};
			
			self.getStyle = function(objStyle) 
			{
				if (self.util.isString(objStyle)) 
				{
					var styleFormat = self.formatsByNames[objStyle];
					return styleFormat ? styleFormat.format : objStyle;
				}
				return objStyle;
			};
			
			self.getStyleID = function(name) 
			{
				var styleFormat = self.formatsByNames[name];
				return styleFormat ? styleFormat.formatId : self.getPredefinedID(name);
			};
			
			self.getPredefinedID = function(name) 
			{
				if (self.predefined[name]) 
				{
					return self.getStyleID(self.add(self.predefined[name],name));
				}
				return null;
			};
			
			self.getFinalTag = function()
			{
				if (self.saveEmpty || self.formats.length > 0) 
				{
					var attributes = {count:self.formats.length};
					var children = [];
					for(var index in self.formats)
					{
						var format = self.formats[index];
						children.push(self.getTag(format.format, format));
					}

					return util.getXML({
						name: self.saveName,
						attributes: attributes,
						children: children
					});
				}
				return '';
			};
			
			self.getTag = function(objStyle,prop) 
			{
				return '';
			};
			
			self.merge = function(formatTo,formatFrom)
			{
				return formatFrom || formatTo;
			};
		};
		
		var XlsxWorkbook = function(util,styles,sharedString,arrSheets)
		{
			var self = this;
			var arrSheet = [];
			
			var process = function() 
			{
				arrSheet = [];
				var sheetValue = "";
				if(arrSheets && arrSheets.length > 0)
				{
					for(var count = 0;count < arrSheets.length;count++)
					{
						var sheetID = count + 1;
						var sheet = new XlsxSheet(util,self,styles,sharedString,arrSheets[count],sheetID);
						sheetValue += sheet.process();
						arrSheet.push(sheet);
					}
				}
				sheetValue = '<sheets>' + sheetValue + '</sheets>';
				return util.getXML({
					name: 'workbook',
					ns: 'spreadsheetml',
					attributes: {'xmlns:r': util.schemas.r,'xmlns:mx': util.schemas.mx,'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: ['<workbookPr/>','<bookViews><workbookView activeTab="0"/></bookViews>', sheetValue, '<definedNames/>', '<calcPr/>']
				});
			};
			
			var getSheet = function(index)
			{
				if(arrSheet && arrSheet.length > index)
				{
					return arrSheet[index];
				}
				return null;
			};
			
			self.process = process;
			self.getSheet = getSheet;
		};
		
		var XlsxSheet = function(util,xlsxWorkbook,styles,sharedString,objSheet,sheetIndex)
		{
			var self = this;
			var arrRow = [];
			var sheetData = null;
			var path = null;
			var relationsPath = null;
			var relationship = null;
			var override = null;
			var maxX = 0;
			var maxY = null;
			var isHeaderRequired = false;
			var arrProcessColumns = [];
			var objProcessRows = {};
			var arrProcessData = [];
			var mergedCells = null;
			var sheetViewAttribute = {};
			var sheetViewPane = {};
			var defaultMargin = {left: 0.7,
					right: 0.7,
					top: 0.75,
					bottom: 0.75,
					header: 0.3,
					footer: 0.3};
			var printConfig = {};
			
			var initialize = function()
			{
				mergedCells = new XlsxMergedCells(util,self);
				getObjColumns();
				getObjRows();
				getData();
				initializeSheetView();
				processProperties();
			};
			
			var getObjColumns = function()
			{
				var arrCol = objSheet.columns;
				for(var index in arrCol)
				{
					var column = util.cloneObject(arrCol[index]);
					if(column.headerText)
					{
						isHeaderRequired = true;
					}
					if (column.style) 
					{
						column.style = styles.addFormat(column.style);
						var style = styles.addFillOutFormat(column.style);
						item.styleID = styles.getStyleID(style);
					}
					arrProcessColumns.push(column);
				}
			};
			
			var getObjRows = function()
			{
				var objRows = objSheet.rowProperties;
				var dataIndex = 0;
				var setStyle = function(tempRow,tempStyle)
				{
					tempRow.style = styles.addFormat(tempStyle);
					var rowStyle = styles.addFillOutFormat(tempRow.style);
					tempRow.styleID = styles.getStyleID(rowStyle);
				};
				if(objSheet.title)
				{
					var item = {};
					var titleStyle = {horizontal: 'center',vertical: 'center',font: {bold: true}};
					if(objSheet.titleStyle)
					{
						titleStyle = objSheet.titleStyle;
					}
					setStyle(item,titleStyle);
					item.skipColumnsStyle = true;
					item.type = "string";
					objProcessRows[dataIndex++] = item;
				}
				if(isHeaderRequired)
				{
					var item = {};
					if(objSheet.headerStyle)
					{
						setStyle(item,objSheet.headerStyle);
						item.skipColumnsStyle = true;
					}
					else
					{
						item.skipColumnsStyle = false;
					}
					item.type = "string";
					objProcessRows[dataIndex++] = item;
				}
				for(var key in objRows)
				{
					var row = util.cloneObject(objRows[key]);
					if (row.style) 
					{
						setStyle(row,row.style);
					}
					row.skipColumnsStyle = row.skipColumnsStyle || false;
					var index = parseInt(key) + dataIndex;
					objProcessRows[index] = row;
				}
			};
			
			var getData = function()
			{
				var dataSource = objSheet.dataSource;
				var tempSource = [];
				var dataIndex = 0;
				if(objSheet.title)
				{
					var item = util.getArrayOfSize(arrProcessColumns.length,function(index){
						if(index == 0)
						{
							return {value: objSheet.title, colspan:arrProcessColumns.length};
						}
						return {value: null};
					});
					tempSource.push(item);
					dataIndex++;
				}
				if(isHeaderRequired)
				{
					var item = [];
					for(var index in arrProcessColumns)
					{
						var column = arrProcessColumns[index];
						item.push(column.headerText || "");
					}
					tempSource.push(item);
					dataIndex++;
				}
				var source = tempSource.concat(dataSource); 
				for(var index in source)
				{
					var rowData = source[index];
					var objRow = objProcessRows[index] || {};
					var rowIndex = parseInt(index) + 1;
					var row = getRowData(rowData,objRow,rowIndex,source);
					arrProcessData.push(row);
					//maxX = Math.max(maxX, row.length);
				}
				
				maxY = arrProcessData.length;
			};
			
			var getRowData = function(rowData,objRow,rowIndex,dataSource)
			{
				var retValue = [];
				if(rowData)
				{
					var rowStyle = null;
					var skipColumnsStyle = false;
					var inserts = [];
					if (!util.isArray(rowData)) 
					{
						rowData = mergeRowDataToRow(rowData,objRow);
					}
					if(rowData)
					{
						rowStyle = rowData.style || null;
						skipColumnsStyle = rowData.skipColumnsStyle;
					}
					for(var index in arrProcessColumns)
					{
						var objCol = arrProcessColumns[index];
						var objCell = getCellDetails(rowData,objCol,index);
						objCol["cellDetails"] = objCol["cellDetails"] || {};
						objCol["cellDetails"][rowIndex] = objCell;
						if(objCell.isObject)
						{
							if(objCell.isSpanRequired)
							{
								rowData = mergeCells(dataSource,rowData,arrProcessColumns,parseInt(index),rowIndex - 1,objCell);
							}
						}
					}
				}
				
				return rowData;
			};
			
			var mergeRowDataToRow = function(rowData,objRow)
			{
				rowData.height = rowData.height || objRow.height;
				rowData.outlineLevel = rowData.outlineLevel || objRow.outlineLevel;
				rowData.type = rowData.type || objRow.type;
				rowData.style = rowData.style ? styles.addFormat(rowData.style) : objRow.style;
				rowData.skipColumnsStyle = rowData.skipColumnsStyle || objRow.skipColumnsStyle;

				return rowData;
			};
			
			var getCellDetails = function(rowData,objCol,index)
			{
				var value = util.isArray(rowData) ? rowData[index] : rowData[objCol.dataField];
				var retValue = {origValue: value, value: value,isObject: false,style: null,isSpanRequired: false};
				if (!util.isUndefinedOrNull(value) && !util.isDate(value) && util.isObject(value))
				{
					retValue.isObject = true;
					if (value.style) 
					{
						retValue.style = value.style;
					}
					if (value.colspan || value.rowspan) 
					{
						retValue.isSpanRequired = true;
					}
					retValue.value = value.value;
				}
				
				return retValue;
			};
			
			var mergeCells = function(dataSource,rowData,arrCol,colIndex,rowIndex,objCell)
			{
				var origValue = objCell.origValue;
				if (origValue.colspan || origValue.rowspan) 
				{
					var colSpan = (origValue.colspan || 1) - 1;
					var rowSpan = (origValue.rowspan || 1) - 1;
					if (colSpan || rowSpan) 
					{
						mergedCells.addMergedCells({ c: colIndex + 1, r: rowIndex + 1 }, { c: colIndex + 1 + colSpan, r: rowIndex + 1 + rowSpan });
						return mergedCells.add(dataSource,rowData,arrCol,colIndex,rowIndex,colSpan,rowSpan,origValue.style);
					}
				}
				return rowData;
			};
			
			var process = function() 
			{
				sheetData = processSheetData();
				setProp();
				return processSheet();
			};
			
			var processSheetData = function() 
			{
				arrRow = [];
				var beforeData = "";
				var rowValue = "";
				var colValue = "";
				var afterData = "";
				if(objSheet)
				{
					colValue = processColumns(arrProcessColumns);
					if(arrProcessColumns && arrProcessColumns.length > 0 && arrProcessData && arrProcessData.length > 0)
					{
						for(var count = 0;count < arrProcessData.length;count++)
						{
							var rowIndex = count + 1;
							var objRow = objProcessRows[count] || {};
							var row = new XlsxRow(util,self,styles,sharedString,arrProcessData[count],arrProcessColumns,rowIndex,objRow);
							rowValue += row.process();
							arrRow.push(row);
						}
					}
				}
				rowValue = '<sheetData>' + rowValue + '</sheetData>';
				beforeData = getBeforeSheetData();
				afterData = getAfterSheetData();
				
				return util.getXML({
					name: 'worksheet',
					ns: 'spreadsheetml',
					attributes: {'xmlns:mc': util.schemas.mc,'xmlns:mv': util.schemas.mv,'xmlns:mx': util.schemas.mx,'xmlns:r': util.schemas.r,'xmlns:x14': util.schemas.x14,'xmlns:x14ac': util.schemas.x14ac,'xmlns:xm': util.schemas.xm},
					children: [beforeData,colValue,rowValue,afterData]
				});
			};
			
			var getBeforeSheetData = function()
			{
				var retValue = "";
				retValue += getSheetViewsTag();
				return retValue;
			};
			
			var getAfterSheetData = function()
			{
				var retValue = "";
				retValue += mergedCells.getTag() + getPrinterTag();
				return retValue;
			};
			
			var processSheet = function() 
			{
				var templateSheet = '<sheet state="visible" name="###sheetName###" sheetId="###sheetIndex###" r:id="rId###sheetIndex###"/>';
				var sheet = templateSheet.replaceAll("###sheetName###",objSheet.name || ("Sheet" + sheetIndex));
				sheet = sheet.replaceAll("###sheetIndex###",sheetIndex);
				return sheet;
			};
			
			var processColumns = function(arrCol)
			{
				if(arrCol && arrCol.length > 0)
				{
					var arrChildren = [];
					for(var count = 0;count < arrCol.length;count++)
					{
						var item = arrCol[count];
						var arrAttr = {'min': item.min || count + 1, 'max': item.max || count + 1};
						if (item.hidden) 
						{
							arrAttr['hidden'] = 1;
						}
						if (item.autoFit) 
						{
							arrAttr['bestFit'] = 1;
						}
						if (item.width) 
						{
							arrAttr['customWidth'] = 1;
							arrAttr['width'] = item.width;
						} 
						else 
						{
							arrAttr['width'] = 9.140625;
						}
						if (item.styleID) 
						{
							arrAttr['style'] = item.styleID;
						}
						arrChildren.push(util.getXML({
							name: 'col',
							attributes: arrAttr
						}));
					}
					return util.getXML({
						name: 'cols',
						children: arrChildren
					});
				}
				return '';
			};
			
			var processProperties = function()
			{
				if(objSheet.freeze)
				{
					var value = objSheet.freeze;
					freeze(value.col, value.row, value.cell, value.activePane);
				}
				else if(objSheet.name == "split") 
				{
					var value = objSheet.split;
					split(value.x, value.y, value.cell, value.activePane);
				}
				if(objSheet.viewAttribute)
				{
					for(var key in objSheet.viewAttribute)
					{
						setSheetViewAttribute({name: key,value: objSheet.viewAttribute[key]});
					}
				}
				if(objSheet.printSetUp)
				{
					if(objSheet.printSetUp.margin)
					{
						setMargin(objSheet.printSetUp.margin);
					}
					if(objSheet.printSetUp.orientation)
					{
						setOrientation(objSheet.printSetUp.orientation);
					}
				}
			};
			
			var getRow = function(index)
			{
				if(arrRow && arrRow.length > index)
				{
					return arrRow[index];
				}
				return null;
			};
			
			var setProp = function()
			{
				path = 'worksheets/sheet' + sheetIndex + '.xml';
				relationsPath = 'worksheets/_rels/sheet' + sheetIndex + '.xml.rels';
				relationship = util.getXML({
					name: 'Relationship',
					attributes: {'Id': 'rId' + sheetIndex,'Type': util.schemas.worksheet,'Target': path}
				});
				override = util.getXML({
					name: 'Override',
					attributes: {'PartName': '/xl/' + path,'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'}
				});
			};
			
			var getPath = function()
			{
				return path;
			};
			
			var getRelationsPath = function()
			{
				return relationsPath;
			};
			
			var getSheetData = function()
			{
				return sheetData;
			};
			
			var getRelationship = function()
			{
				return relationship;
			};
			
			var getOverride = function()
			{
				return override;
			};
			
			var initializeSheetView = function()
			{
				var getBooleanValue = function(item)
				{
					if(!item || util.getBooleanValue(item.value) == null)
					{
						xlsxUtil.throwNSError(item.name + " attribute does not have a proper value for Sheet View Attribute"); 
					}
					return util.getBooleanValue(item.value).toString();
				};
				
				sheetViewAttribute = {
						defaultGridColor: {
							value: null,
							getValue: getBooleanValue
						},
						colorId: {
							value: null
						},
						rightToLeft: {
							value: null,
							getValue: getBooleanValue
						},
						showFormulas: {
							value: null,
							getValue: getBooleanValue
						},
						showGridLines: {
							value: null,
							getValue: getBooleanValue
						},
						showOutlineSymbols: {
							value: null,
							getValue: getBooleanValue
						},
						showRowColHeaders: {
							value: null,
							getValue: getBooleanValue
						},
						showRuler: {
							value: null,
							getValue: getBooleanValue
						},
						showWhiteSpace: {
							value: null,
							getValue: getBooleanValue
						},
						showZeros: {
							value: null,
							getValue: getBooleanValue
						},
						tabSelected: {
							value: null,
							getValue: getBooleanValue
						},
						topLeftCell: {
							value: null //A1
						},
						view: {
							value: 'normal' //normal | pageBreakPreview | pageLayout
						},
						windowProtection: {
							value: null,
							getValue: getBooleanValue
						},
						zoomScale: {
							value: null //10-400
						},
						zoomScaleNormal: {
							value: null //10-400
						},
						zoomScalePageLayoutView: {
							value: null //10-400
						},
						zoomScaleSheetLayoutView: {
							value: null //10-400
						}
				};
			};
			
			var setSheetViewAttribute = function(objAttr) 
			{
				if(objAttr && objAttr.name)
				{
					if (objAttr.name == "freeze") 
					{
						freeze(value.col, value.row, value.cell, value.activePane);
					} 
					else if(objAttr.name == "split") 
					{
						split(value.x, value.y, value.cell, value.activePane);
					}
					else if (sheetViewAttribute[objAttr.name] && !util.isUndefinedOrNull(objAttr.value)) 
					{
						if(sheetViewAttribute[objAttr.name].getValue)
						{
							sheetViewAttribute[objAttr.name].value = sheetViewAttribute[objAttr.name].getValue(objAttr);
						}
						else
						{
							sheetViewAttribute[objAttr.name].value = objAttr.value;
						}
					}
				}
			};
			
			var freeze = function(colNo,rowNo,cell,activePane) 
			{
				sheetViewPane = {
					state: 'frozen',
					xSplit: parseInt(colNo),
					ySplit: parseInt(rowNo),
					topLeftCell: util.getCanonCell(cell) || util.getLetterFromCells(parseInt(colNo) + 1, parseInt(rowNo) + 1),
					activePane: activePane || 'bottomRight'
				};
			};
			
			var split = function(xPos,yPos,cell,activePane) 
			{
				sheetViewPane = {
					state: 'split',
					xSplit: parseInt(xPos) * 20,
					ySplit: parseInt(yPos) * 20,
					topLeftCell: util.getCanonCell(cell) || 'A1',
					activePane: activePane || 'bottomRight'
				};
			};
			
			var getSheetViewsTag = function()
			{
				var arrChildren = [];
				if(sheetViewPane && Object.keys(sheetViewPane).length > 0)
				{
					var attr = {state: sheetViewPane.state, xSplit: sheetViewPane.xSplit, ySplit: sheetViewPane.ySplit, topLeftCell: sheetViewPane.topLeftCell, activePane: sheetViewPane.activePane};
					arrChildren.push(util.getXML({
						name: 'pane',
						attributes:attr
					}));
				}
				var attributes = {workbookViewId: 0};
				for(var key in sheetViewAttribute)
				{
					if(!util.isUndefinedOrNull(sheetViewAttribute[key].value))
					{
						attributes[key] = sheetViewAttribute[key].value;
					}
				}
				
				var arrSheetView = [util.getXML({
					name: 'sheetView',
					attributes:attributes,
					children: arrChildren
				})];
				
				return util.getXML({
					name: 'sheetViews',
					children:arrSheetView
				});
			};
			
			var setMargin = function(margin)
			{
				printConfig.margin = util.setObjectWithDefaults(margin,defaultMargin);
			};
			
			var setOrientation = function(orientation)
			{
				if (orientation === 'portrait' || orientation === 'landscape')
				{
					printConfig.orientation = orientation;
				}
			};
			
			var getPrinterTag = function()
			{
				var retValue = '';
				if(printConfig)
				{
					var margin = printConfig.margin;
					if(margin) 
					{
						retValue += util.getXML({
							name: 'pageMargins',
							attributes: margin
						});
					}
					if(printConfig.orientation)
					{
						retValue += util.getXML({
							name: 'pageSetup',
							attributes: {orientation: printConfig.orientation}
						});
					}
				}
				return retValue;
			};
			
			initialize();
			
			self.process = process;
			self.getRow = getRow;
			self.setProp = setProp;
			self.getPath = getPath;
			self.getRelationsPath = getRelationsPath;
			self.getSheetData = getSheetData;
			self.getRelationship = getRelationship;
			self.getOverride = getOverride;
			self.getCellDetails = getCellDetails;
			self.freeze = freeze;
			self.split = split;
			self.setViewAttribute = setSheetViewAttribute;
			self.setMargin = setMargin;
			self.setOrientation = setOrientation;
		};
		
		var XlsxRow = function(util,xlsxSheet,styles,sharedString,rowData,arrCol,rowIndex,objRow)
		{
			var self = this;
			var arrCell = [];
			
			var process = function() 
			{
				arrCell = [];
				var cellValue = "";
				if(arrCol && arrCol.length > 0)
				{
					for(var count = 0;count < arrCol.length;count++)
					{
						var objCol = arrCol[count];
						var objCell = objCol["cellDetails"][rowIndex] || xlsxSheet.getCellDetails(rowData,objCol,count);
						var cell = new XlsxCell(util,self,styles,sharedString,objCol,count + 1,rowData,rowIndex,objCell,objRow,objRow.skipColumnsStyle);
						cellValue += cell.process();
						arrCell.push(cell);
					}
				}
				return util.getXML({
					name: 'row',
					attributes: getAttr(),
					children: [cellValue]
				});
			};
			
			var getAttr = function()
			{
				var attr = {'r': rowIndex};
				if (!util.isUndefinedOrNull(objRow.height)) 
				{
					attr["customHeight"] = 1;
					attr["ht"] = objRow.height;
				}
				if (objRow.styleID) 
				{
					attr["customFormat"] = 1;
					attr["s"] = objRow.styleID;
				}
				if (objRow.outlineLevel) 
				{
					attr["outlineLevel"] = objRow.outlineLevel;
				}
				return attr;
			};
			
			var getCell = function(index)
			{
				if(arrCell && arrCell.length > index)
				{
					return arrCell[index];
				}
				return null;
			};
			
			self.process = process;
			self.getCell = getCell;
			
		};
		
		var XlsxCell = function(util,xlsxRow,styles,sharedString,objCol,cellIndex,rowData,rowIndex,objCell,objRow,skipColumnsStyle)
		{
			var self = this;
			var dataType = null;
			
			initialize = function()
			{
				
			};
			
			var process = function() 
			{
				var value = objCell.value;
				var cellStyle = objCell.style;
				var objValue = objCell.origValue;
				var cellType = getCellType(value);
				var predefinedStyle = null;
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						predefinedStyle = cellType;
						break;
					}
				}
				var columnStyle = !skipColumnsStyle ? objCol.style : null;
				var rowStyle = objRow.style;
				var finalCellStyleID = styles.getStyleID(styles.merge(predefinedStyle,columnStyle,rowStyle,cellStyle));
				var objCellValue = getCellObj(cellType,value);
				var attributes = getAttr(cellIndex - 1,rowIndex,cellType,finalCellStyleID);
				var children = "";
				if (!util.isUndefinedOrNull(objCellValue.formula)) 
				{
					children = '<v>' + objCellValue.formula + '</v>';
				}
				else if (!util.isUndefinedOrNull(objCellValue.value))
				{
					/*if(cellType == "string")
					{
						children = '<is><t>' + objCellValue.value + '</t></is>';
					}
					else
					{*/
						children = '<v>' + objCellValue.value + '</v>';
					//}
				}
				return util.getXML({
					name: 'c',
					attributes: attributes,
					children: [children]
				});
			};
			
			var getAttr = function(index,rowIndex,cellType,styleID)
			{
				var attr = {'r': generatorCellNumber(index, rowIndex)};
				if (styleID) 
				{
					attr["s"] = styleID;
				}
				switch (cellType)
				{
					case "string":
						//attr["t"] = "inlineStr";
						attr["t"] = "s"; 
					break;
					case "boolean":
						attr["t"] = "b"; 
					break;
				}
				return attr;
			};
			
			var getCellType = function(value)
			{
				if(objCell && objCell.type)
				{
					return objCell.type;
				}
				else if (rowData && rowData.type) 
				{
					return rowData.type;
				}
				else if (objRow && objRow.type) 
				{
					return objRow.type;
				}
				if(objCol && objCol.type)
				{
					return objCol.type;
				}
				else if (typeof value === 'number') 
				{
					return 'number';
				} 
				else if (typeof value === 'string') 
				{
					return 'string';
				}
				else if(util.isDate(value))
				{
					return "date";
				}
				return 'string';
			};
			
			var getCellObj = function(cellType,cellValue) 
			{
				var retValue = {value: null,formula: null,isString: false};
				
				var formulaFunc = function(objRet,value,sharedString)
				{
					objRet.formula = util.escapeString(value);
					return objRet;
				};
				
				var stringFunc = function(objRet,value,sharedString)
				{
					objRet.value = sharedString.add(value);
					//objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				
				var mapCellType = {string: {func: stringFunc},
								   formula:{func: formulaFunc}};
				for(var key in mapCellType)
				{
					if(cellType == key)
					{
						return mapCellType[key].func(retValue,cellValue,sharedString);
					}
				}
				for(var key in util.numberPredifined)
				{
					if(cellType == key)
					{
						return util.numberPredifined[key].cellObjFunc(retValue,cellValue,sharedString);
					}
				}
				retValue.value = cellValue;
				return retValue;
			};
			
			var generatorCellNumber = function(index, rowNumber)
			{
				return generateColumnLetter(index) + rowNumber;
			};
			
			var generateColumnLetter = function(colIndex) 
			{
				if (typeof colIndex !== 'number') 
				{
					return '';
				}
				var prefix = Math.floor(colIndex / 26);
				var letter = String.fromCharCode(97 + (colIndex % 26)).toUpperCase();
				if (prefix === 0) 
				{
					return letter;
				}
				return generateColumnLetter(prefix - 1) + letter;
			};
			
			initialize();
			
			self.process = process;
		};
		
		var XlsxSharedStrings = function(util)
		{
			var self = this;
			var objString = {};
			var arrString = [];
			var index = 0;
			var regexSpace = /^\s|\s$/;
			
			var add = function(str) 
			{
				var strIndex = objString[str];
				if (util.isUndefinedOrNull(strIndex)) 
				{
					strIndex = index++;
					objString = strIndex;
					arrString[strIndex] = str;
				}
				return strIndex;
			};
			
			var getAllString = function()
			{
				return arrString;
			};
			
			var hasString = function()
			{
				return index > 0;
			};
			
			var getTag = function()
			{
				var strResult = "";
				for(var index in arrString)
				{
					var str = util.escapeString(arrString[index]);
					if (regexSpace.test(str)) 
					{
						strResult += '<si><t xml:space="preserve">' + str + '</t></si>';
					}
					else
					{
						strResult += '<si><t>' + str + '</t></si>';
					}
				}
				var retValue = getTagStart(index) + strResult + getTagEnd();
				reset();
				return retValue;
			};
			
			var getTagStart = function(count) 
			{
				return util.xmlPrefix + '<sst xmlns="' + util.schemas.spreadsheetml + '" count="' + count + '" uniqueCount="' + count + '">';
			};

			var getTagEnd = function() 
			{
				return '</sst>';
			};
			
			var reset = function()
			{
				objString = {};
				arrString = [];
				//not setting index as 0 so that while saving other api can figure out that shared String exists
				//index = 0;
			};
			
			self.add = add;
			self.getAllString = getAllString;
			self.getTag = getTag;
			self.hasString = hasString;
		};
		
		var XlsxMergedCells = function(util,sheet)
		{
			var self = this;
			var arrCells = [];
			
			var add = function(dataSource,rowData,arrCol,colIndex,rowIndex,colSpan,rowSpan,style)
			{
				if(colSpan)
				{
					var getEmptyCell = function(index)
					{
						return {value: null,style: style};
					};
					if(!util.isArray(rowData))
					{
						rowData = convertObjectToArray(rowData,arrCol);
					}
					var arrTill = copyArray(rowData.slice(0, colIndex + 1));
					var arrEmpty = util.getArrayOfSize(colSpan,getEmptyCell);
					arrEmpty = copyArray(arrEmpty);
					var arrAfter = copyArray(rowData.slice(colIndex + 1));
					rowData = [].concat(arrTill,arrEmpty,arrAfter);
				}
				if(rowSpan) 
				{
					var index = 1;
					for(var count = (rowIndex + 1);(count < dataSource.length && index < rowSpan);count++)
					{
						var item = dataSource[count];
						util.isArray(item) ? (item[colIndex] = "") : (item[arrCol[colIndex].dataField] = null);
						index++;
					}
					while(index < rowSpan)
					{
						var item = {};
						for(var count = 0;count < arrCol.length;count++)
						{
							if(count == colIndex)
							{
								item[arrCol[colIndex].dataField] = {style: style,value: null};
							}
							else
							{
								item[arrCol[colIndex].dataField] = null;
							}
						}
						dataSource.push(item);
						index++;
					}
				}
				
				return rowData;
			};
			
			var addMergedCells = function(fromCell,toCell) 
			{
				arrCells.push([fromCell, toCell]);
			};
			
			var getTag = function()
			{
				if (arrCells.length > 0) 
				{
					var arrChildren = [];
					for(var index in arrCells)
					{
						var mergeCell = arrCells[index];
						arrChildren.push(util.getXML({
							name: 'mergeCell',
							attributes: {'ref': util.getCanonCell(mergeCell[0]) + ':' + util.getCanonCell(mergeCell[1])}
						}));
					}
					return util.getXML({
						name: 'mergeCells',
						attributes: {'count': arrCells.length},
						children: arrChildren
					});
				}
			};
			
			var convertObjectToArray = function(rowData,arrCol)
			{
				var retValue = Array(arrCol.length);
				for(var count = 0;count < arrCol.length;count++)
				{
					var objCol = arrCol[count];
					retValue[count] = rowData[objCol.dataField];
				}
				return retValue;
			};
			
			var copyArray = function(arrSource)
			{
				if (util.isArray(arrSource)) 
				{
					var retValue = Array(arrSource.length);
					for (var i = 0; i < arrSource.length; i++) 
					{ 
						retValue[i] = arrSource[i]; 
					} 
					return retValue; 
				} 
				return Array.from(arrSource); 
			};
			
			self.add = add;
			self.addMergedCells = addMergedCells;
			self.getTag = getTag;
		};
		
		var XlsxUtil = function()
		{
			var self = this;
			var objSheetsProp = {};
			
			var xmlPrefix = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
			var schemas = {
					'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
					'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',
					'mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
					'mv': 'urn:schemas-microsoft-com:mac:vml',
					'x14': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main',
					'x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
					'xm': 'http://schemas.microsoft.com/office/excel/2006/main',
					'spreadsheetml': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
					'relationshipPackage': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'worksheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
					'stylesheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
					'sharedStrings': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
					'contentTypes': 'http://schemas.openxmlformats.org/package/2006/content-types',
					
					'officeDocument': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
					'package': 'http://schemas.openxmlformats.org/package/2006/relationships',
					'table': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
					'spreadsheetDrawing': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
					'drawing': 'http://schemas.openxmlformats.org/drawingml/2006/main',
					'drawingRelationship': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
					'image': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
					'chart': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
					'hyperlink': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink'
			};
			var numberPredifined = null;
			
			var initialize = function()
			{
				var getDateTimeCellObj = function(objRet,value,sharedString)
				{
					var date = getDateTimeValue(value);
					if(date)
					{
						objRet.value = date;
					}
					else
					{
						objRet.value = sharedString.add(String(value));
						//objRet.value = value;
						objRet.isString = true;
					}
					return objRet;
				};
				var getNumberCellObj = function(objRet,value,sharedString)
				{
					objRet.value = value;
					objRet.isString = false;
					return objRet;
				};
				numberPredifined = {
						date: {formatId: 14,cellObjFunc:getDateTimeCellObj}, //mm-dd-yy
						time: {formatId: 21,cellObjFunc:getDateTimeCellObj}, //h:mm:ss
						integer: {formatId: 1,cellObjFunc:getNumberCellObj},
						double: {formatId: 2,cellObjFunc:getNumberCellObj}
				};
			};
			
			var getXML = function(config) 
			{
				var retValue = '<' + config.name;
				var content = '';

				if (config.ns) 
				{
					retValue = xmlPrefix + retValue + ' xmlns="' + schemas[config.ns] + '"';
				}
				if (config.attributes) 
				{
					for(var key in config.attributes)
					{
						retValue += ' ' + key + '="' + escapeString(config.attributes[key]) + '"';
					}
				}
				if (!isUndefinedOrNull(config.value)) 
				{
					content += escapeString(config.value);
				}
				if (config.children) 
				{
					content += config.children.join('');
				}
				if (content) 
				{
					retValue += '>' + content + '</' + config.name + '>';
				} 
				else 
				{
					retValue += '/>';
				}
				return retValue;
			};
			
			var escapeString = function(str)
			{
				return str;
			};
			
			var addSheetProp = function(prop,value)
			{
				objSheetsProp[prop] = objSheetsProp[prop] ? (objSheetsProp[prop] + " " + value) : value;
			};
			
			var getSheetProp = function(prop)
			{
				return objSheetsProp[prop];
			};
			
			var getCanonColor = function(color) 
			{
				return color[0] === '#' ? 'FF' + color.substr(1) : color;
			};
			
			var getColorTag = function(color) 
			{
				if (isString(color)) 
				{
					return getXML({
						name: 'color',
						attributes: {'rgb': getCanonColor(color)}
					});
				} 
				else 
				{
					var attributes = {};
					if (color.tint) 
					{
						attributes['tint'] = color.tint;
					}
					if (color.auto) 
					{
						attributes['auto'] = !!color.auto;
					}
					if (color.theme) 
					{
						attributes['theme'] = color.theme;
					}
					return getXML({
						name: 'color',
						attributes: attributes
					});
				}
			};
			
			var hasInArray = function(arrSource,value)
			{
				 return (arrSource.indexOf(value) > -1);
			};
			
			var isObject = function(refObject)
			{
				if (typeof refObject === 'object' && refObject !== null) 
				{
				    return true;
				} 
				return false;
			};
			
			var isString = function(object) 
			{
			    return typeof object == "string";
			};
			
			var isDate = function(object) 
			{
				return (Object.prototype.toString.call(object) === "[object Date]"); 
			};
			
			var isArray = function(object)
			{
				return Array.isArray(object);
			};
			
			var isObjectEmpty = function(obj)
			{
				for(var key in obj) 
				{
			        if(obj.hasOwnProperty(key))
			        {
			        	return false;
			        }
			    }
			    return true;
			};
			
			var getDateTimeValue = function(value)
			{
				var timezoneOffset = new Date().getTimezoneOffset() * 60 * 1000;
				var dateValue = isDate(value) ? value.valueOf() : value;
				var date = 25569.0 + (dateValue - timezoneOffset) / (60 * 60 * 24 * 1000);
				if (isFinite(date)) 
				{
					return date;
				}
				return null;
			};
			
			var cloneObject = function(objSrc)
			{
				return JSON.parse(JSON.stringify(objSrc));
			};
			
			var getArrayOfSize = function(length,callback)
			{
				var index = -1;
		        var retValue = Array(length);
		        if(callback)
		        {
		        	while (++index < length) 
				    {
		        		retValue[index] = callback(index);
				    }
		        }
		        return retValue;
			};
			
			var getLetterFromCells = function(fromCell,toCell)
			{
				var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
				var retValue = "";
				var strData = '';
				var count = fromCell;
				var index = null;
				do 
				{
					index = (count - 1) % 26;
					strData = alphabet[index] + strData;
					count = (count - (index + 1)) / 26;
				} while (count > 0);
				retValue = strData + (toCell || '');;
				return retValue;
			};
			
			var getCellsFromLetter = function(cell) 
			{
				var retValue = {x: 0,y: 0};
				var len = cell.length;
				for (var count = 0; count < len; count++) 
				{
					var charCode = cell.charCodeAt(count);
					if (charCode >= 65) 
					{
						retValue.x = retValue.x * 26 + charCode - 64;
					} 
					else 
					{
						retValue.y = parseInt(cell.slice(count), 10);
						break;
					}
				}
				return retValue;
			};
			
			var getCanonCell = function(cell) 
			{
				if(isObject(cell))
				{
					return getLetterFromCells(cell.c || 1, cell.r || 1);
				}
				return cell;
			};
			
			var getBooleanValue = function(value)
			{
				if(['true', 'yes', '1'].includes(value)) 
				{
				    return  true;   
				}
				else if(['false', 'no', '0'].includes(value)) 
				{
				    return  false;  
				}
				return false;
			};
			
			var throwNSError = function(message)
			{
			 	throw new Error("Error in " + "NSXlsxExport" + " with details::" + message);
			};
			
			var isUndefinedOrNull = function(object) 
			{
			    return (typeof object == "undefined" || object === null);
			};
			
			var setObjectWithDefaults = function(objCurrent,objDefault)
			{
				if(objCurrent)
				{
					var objReturn = cloneObject(objCurrent);
					if(objDefault)
					{
						for(var key in objDefault)
						{
							objReturn[key] = objDefault[key];
						}
					}
					return objReturn;
				}
				return objDefault;
			};
			
			initialize();
			
			self.getXML = getXML;
			self.escapeString = escapeString;
			self.addSheetProp = addSheetProp;
			self.getSheetProp = getSheetProp;
			self.getCanonColor = getCanonColor;
			self.getColorTag = getColorTag;
			self.hasInArray = hasInArray;
			self.isObject = isObject;
			self.isString = isString;
			self.isDate = isDate;
			self.isArray = isArray;
			self.isObjectEmpty = isObjectEmpty;
			self.getDateTimeValue = getDateTimeValue;
			self.cloneObject = cloneObject;
			self.getArrayOfSize = getArrayOfSize;
			self.getLetterFromCells = getLetterFromCells;
			self.getCellsFromLetter = getCellsFromLetter;
			self.getCanonCell = getCanonCell;
			self.getBooleanValue = getBooleanValue;
			self.throwNSError = throwNSError;
			self.isUndefinedOrNull = isUndefinedOrNull;
			self.setObjectWithDefaults = setObjectWithDefaults;
			self.xmlPrefix = xmlPrefix;
			self.schemas = schemas;
			self.numberPredifined = numberPredifined;
		};
		
		self.process = process;
		
		initialize();
	};
	
	return NSXlsxExport;
})();
nsModuleExport(this,"NSXlsxExport",NSXlsxExport);
